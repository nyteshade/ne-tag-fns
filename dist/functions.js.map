{"version":3,"sources":["../src/functions.js"],"names":["DEDENT","DEDENT_DROP_LOWEST","DEDENT_FULL","variations","Map","handleSubstitutions","strings","subs","convert","object","string","join","Array","isArray","length","reduce","prev","cur","i","cautiouslyApplyEach","array","fns","log","keepOldValueOnFalseyReturn","items","from","forEach","item","itemIndex","itemArray","newItem","fn","bindFunctor","functor","bind","error","console","cautiouslyApply","measureIndents","config","preWork","perLine","postWork","whitespace","regexp","RegExp","source","indents","split","map","s","a","search","exec","customDedent","options","dropLowest","mask","has","get","ss","skipStrip","NOOP_PREWORK","stripEmptyFirstAndLast","dropLowestIndents","NOOP_POSTWORK","excess","Math","min","replace","dedent","gql","inline","inlineJoin","joiner","allLeading","allTrailing","_inlineJoiner","trim","postStripEmptyFirstAndLast","set","stringsAndIndents","first","last","toProcess","shift","pop","push","reduceRight","c","value","fnName","trimL","trimR","splice","values","Set","lowest","delete","trimAllIndents","Number","MAX_SAFE_INTEGER","NOOP_PERLINE","index"],"mappings":";;AAEA;AACA;AACA,MAAMA,MAAM,GAAG,CAAf;AACA,MAAMC,kBAAkB,GAAG,CAA3B;AACA,MAAMC,WAAW,GAAGF,MAAM,GAAGC,kBAA7B;;AAEA;AACA;AACA;AACA,MAAME,UAAiC,GAAG,IAAIC,GAAJ,EAA1C;;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBO,SAASC,mBAAT;AACLC,OADK;AAELC,IAFK;AAGLC,OAAiB,GAAIC,MAAD,IAAY,KAAKA,MAHhC;AAIG;AACR,MAAIC,MAAM,GAAGJ,OAAO,CAACK,IAAR,CAAa,EAAb,CAAb;;AAEA,MAAIJ,IAAI,IAAIK,KAAK,CAACC,OAAN,CAAcN,IAAd,CAAR,IAA+BA,IAAI,CAACO,MAAxC,EAAgD;AAC9CJ,IAAAA,MAAM,GAAGH,IAAI,CAACQ,MAAL;AACP,KAACC,IAAD,EAAOC,GAAP,EAAYC,CAAZ,KAAmB,GAAEF,IAAK,GAAER,OAAO,CAACS,GAAD,CAAM,GAAEX,OAAO,CAACY,CAAC,GAAG,CAAL,CAAQ,EADnD;AAEPZ,IAAAA,OAAO,CAAC,CAAD,CAFA,CAAT;;AAID;;AAED,SAAOI,MAAP;AACD;;AAED;;;;;;;;;;;;;;;;;AAiBO,SAASS,mBAAT;AACLC,KADK;AAELC,GAFK;AAGLC,GAAY,GAAG,IAHV;AAILC,0BAAmC,GAAG,KAJjC;AAKS;AACd,MAAIC,KAAK,GAAGZ,KAAK,CAACa,IAAN,CAAWL,KAAX,CAAZ;;AAEA,MAAII,KAAK,IAAIZ,KAAK,CAACC,OAAN,CAAcW,KAAd,CAAT,IAAiCH,GAAjC,IAAwCT,KAAK,CAACC,OAAN,CAAcQ,GAAd,CAA5C,EAAgE;AAC9DG,IAAAA,KAAK,CAACE,OAAN,CAAc,CAACC,IAAD,EAAOC,SAAP,EAAkBC,SAAlB,KAAgC;AAC5C,UAAIC,OAAO,GAAGH,IAAd;;AAEAN,MAAAA,GAAG,CAACK,OAAJ,CAAYK,EAAE,IAAI;AAChB,YAAI;AACF,cAAIC,WAAW,GAAGpB,KAAK,CAACC,OAAN,CAAckB,EAAd,KAAqBA,EAAE,CAAC,CAAD,CAAzC;AACA,cAAIE,OAAO,GAAGD,WAAW;AACrBD,UAAAA,EAAE,CAAC,CAAD,CAAF,CAAMG,IAAN,CAAWJ,OAAX,CADqB;AAErBlB,UAAAA,KAAK,CAACC,OAAN,CAAckB,EAAd,IAAoBA,EAAE,CAAC,CAAD,CAAtB,GAA4BA,EAFhC;;AAIA,cAAIR,0BAAJ;AACEO,UAAAA,OAAO,GAAGG,OAAO,CAACH,OAAD,EAAUF,SAAV,EAAqBC,SAArB,CAAP,IAA0CC,OAApD,CADF;;AAGEA,UAAAA,OAAO,GAAGG,OAAO,CAACH,OAAD,EAAUF,SAAV,EAAqBC,SAArB,CAAjB;AACH;AACD,eAAOM,KAAP,EAAc;AACZ,cAAIb,GAAJ,EAAS;AACPc,YAAAA,OAAO,CAACD,KAAR,CAAcA,KAAd;AACD;AACF;AACF,OAjBD;;AAmBAX,MAAAA,KAAK,CAACI,SAAD,CAAL,GAAmBE,OAAnB;AACD,KAvBD;AAwBD;;AAED,SAAON,KAAP;AACD;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BO,SAASa,eAAT;AACLV,IADK;AAELN,GAFK;AAGLC,GAAY,GAAG,IAHV;AAILC,0BAAmC,GAAG,KAJjC;AAKE;AACP,MAAIF,GAAG,IAAIT,KAAK,CAACC,OAAN,CAAcQ,GAAd,CAAX,EAA+B;AAC7BA,IAAAA,GAAG,CAACK,OAAJ,CAAYK,EAAE,IAAI;AAChB,UAAI;AACF,YAAIC,WAAW,GAAGpB,KAAK,CAACC,OAAN,CAAckB,EAAd,KAAqBA,EAAE,CAAC,CAAD,CAAzC;AACA,YAAIE,OAAO,GAAGD,WAAW;AACrBD,QAAAA,EAAE,CAAC,CAAD,CAAF,CAAMG,IAAN,CAAWP,IAAX,CADqB;AAErBf,QAAAA,KAAK,CAACC,OAAN,CAAckB,EAAd,IAAoBA,EAAE,CAAC,CAAD,CAAtB,GAA4BA,EAFhC;;AAIA,YAAIR,0BAAJ;AACEI,QAAAA,IAAI,GAAGM,OAAO,CAACN,IAAD,CAAP,IAAiBA,IAAxB,CADF;;AAGEA,QAAAA,IAAI,GAAGM,OAAO,CAACN,IAAD,CAAd;AACH;AACD,aAAOQ,KAAP,EAAc;AACZ,YAAIb,GAAJ,EAAS;AACPc,UAAAA,OAAO,CAACD,KAAR,CAAcA,KAAd;AACD;AACF;AACF,KAjBD;AAkBD;;AAED,SAAOR,IAAP;AACD;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyDO,SAASW,cAAT;AACL5B,MADK;AAEL6B,MAAc,GAAG;AACfC,EAAAA,OAAO,EAAE,EADM;AAEfC,EAAAA,OAAO,EAAE,EAFM;AAGfC,EAAAA,QAAQ,EAAE,EAHK,EAFZ;;AAOLC,UAAkB,GAAG,OAPhB;AAQgC;AACrC,MAAIC,MAAM,GAAG,IAAIC,MAAJ,CAAY,KAAIF,UAAU,CAACG,MAAO,IAAlC,CAAb;AACA,MAAIxC,OAAJ;AACA,MAAIyC,OAAJ;;AAEA,MAAInC,KAAK,CAACC,OAAN,CAAcH,MAAd,CAAJ,EAA2B;AACzBA,IAAAA,MAAM,GAAGA,MAAM,CAACC,IAAP,CAAY,IAAZ,CAAT;AACD;;AAEDD,EAAAA,MAAM,GAAG2B,eAAe,CAAC3B,MAAD,EAAS6B,MAAM,CAACC,OAAhB,EAAyB,IAAzB,EAA+B,IAA/B,CAAxB;AACAlC,EAAAA,OAAO,GAAGI,MAAM,CAACsC,KAAP,CAAa,OAAb,CAAV;AACAD,EAAAA,OAAO,GAAGzC,OAAO,CAAC2C,GAAR,CAAY,CAACC,CAAD,EAAIhC,CAAJ,EAAOiC,CAAP,KAAa;AACjC,QAAIC,MAAJ;;AAEAF,IAAAA,CAAC,GAAGb,eAAe,CAACa,CAAD,EAAIX,MAAM,CAACE,OAAX,EAAoB,IAApB,EAA0B,KAA1B,CAAnB;;AAEAW,IAAAA,MAAM,GAAGR,MAAM,CAACS,IAAP,CAAYH,CAAZ,CAAT;AACA,WAAOE,MAAM,IAAIA,MAAM,CAAC,CAAD,CAAN,CAAUtC,MAApB,IAA8B,CAArC;AACD,GAPS,CAAV;;AASA,SAAOuB,eAAe,CAAC,CAAC/B,OAAD,EAAUyC,OAAV,CAAD,EAAqBR,MAAM,CAACG,QAA5B,CAAtB;AACD;;AAED;;;;;;;;;;;;;;;;;;;;;AAqBO,SAASY,YAAT,CAAsBC,OAAe,GAAG,EAAEC,UAAU,EAAE,IAAd,EAAxC,EAA8D;AACnE,MAAIC,IAAI,GAAGzD,MAAM;AACZuD,EAAAA,OAAO,CAACC,UAAR,GAAqBvD,kBAArB,GAA0C,CAD9B,CAAjB;;AAGA,MAAIE,UAAU,CAACuD,GAAX,CAAeD,IAAf,CAAJ,EAA0B;AACxB,WAAOtD,UAAU,CAACwD,GAAX,CAAeF,IAAf,CAAP;AACD;;AAED,SAAO,UAAUG,EAAV,EAAc,GAAGrD,IAAjB,EAAuB;AAC5B,QAAI,CAACD,OAAD,EAAUyC,OAAV,IAAqBT,cAAc;AACrC;AACA;AACAjC,IAAAA,mBAAmB,CAACuD,EAAD,EAAKrD,IAAL,CAHkB;;AAKrC;AACA;AACA;AACEiC,MAAAA,OAAO,EAAE;AACPe,MAAAA,OAAO,CAACM,SAAR;AACIC,MAAAA,YADJ;AAEIC,MAAAA,sBAHG,CADX;;AAMErB,MAAAA,QAAQ,EAAE;AACRa,MAAAA,OAAO,CAACC,UAAR;AACIQ,MAAAA,iBADJ;AAEIC,MAAAA,aAHI,CANZ,EAPqC,CAAvC;;;;;AAqBA;AACA,QAAIC,MAAM,GAAGC,IAAI,CAACC,GAAL,CAAS,GAAGrB,OAAZ,KAAwB,CAArC;;AAEA;AACA;AACA,QAAImB,MAAM,GAAG,CAAb,EAAgB;AACd5D,MAAAA,OAAO,GAAGA,OAAO,CAAC2C,GAAR,CAAYC,CAAC,IAAIA,CAAC,CAACmB,OAAF,CAAU,WAAV,EAAuB,EAAvB,CAAjB,CAAV;AACA/D,MAAAA,OAAO,GAAGA,OAAO,CAAC2C,GAAR,CAAYC,CAAC,IAAIA,CAAC,CAACmB,OAAF;AACzB,UAAIxB,MAAJ,CAAY,YAAWqB,MAAO,GAA9B,CADyB,EACU,EADV,CAAjB,CAAV;;AAGD;;AAED;AACA,WAAO5D,OAAO,CAACK,IAAR,CAAa,IAAb,CAAP;AACD,GApCD;AAqCD;;AAED;;;;;;;;;;;;;;AAcO,SAAS2D,MAAT,CAAgBhE,OAAhB,EAAyB,GAAGC,IAA5B,EAAkC;AACvC,SAAO+C,YAAY,CAAC,EAACE,UAAU,EAAE,KAAb,EAAD,CAAZ;AACLlD,EAAAA,OADK;AAEL,KAAGC,IAFE,CAAP;;AAID;;AAED;;;;;;;;;;;;;;;;;AAiBO,SAASiD,UAAT,CAAoBlD,OAApB,EAA6B,GAAGC,IAAhC,EAAsC;AAC3C,SAAO+C,YAAY,CAAC,EAACE,UAAU,EAAE,IAAb,EAAD,CAAZ;AACLlD,EAAAA,OADK;AAEL,KAAGC,IAFE,CAAP;;AAID;;AAED;;;;;;;;AAQO,MAAMgE,GAAG,GAAGf,UAAZ;;AAEP;;;;;;;;;;;;;;;;AAgBO,SAASgB,MAAT,CAAgBZ,EAAhB,EAAoB,GAAGrD,IAAvB,EAA6B;AAClC,SAAOkE,UAAU,CAAC,GAAD,CAAV,CAAgBb,EAAhB,EAAoB,GAAGrD,IAAvB,CAAP;AACD;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BO,SAASkE,UAAT;AACLC,MAAM,GAAG,EADJ;AAELC,UAAU,GAAG,KAFR;AAGLC,WAAW,GAAG,KAHT;AAIL;AACA,SAAO,SAASC,aAAT,CAAuBjB,EAAvB,EAA2B,GAAGrD,IAA9B,EAAoC;AACzC,QAAIG,MAAM,GAAGL,mBAAmB,CAACuD,EAAD,EAAK,GAAGrD,IAAR,CAAhC;AACA6B,IAAAA,OAAO,CAACd,GAAR,CAAa,cAAaoD,MAAO,KAAIC,UAAW,KAAIC,WAAY,QAAOlE,MAAO,GAA9E;;AAEA,QAAI,CAACJ,OAAD,EAAUyC,OAAV,IAAqBT,cAAc,CAAC5B,MAAD,EAAS;AAC9C8B,MAAAA,OAAO,EAAE,EADqC;AAE9CC,MAAAA,OAAO,EAAE,CAACS,CAAC,IAAIA,CAAC,CAAC4B,IAAF,EAAN,CAFqC;AAG9CpC,MAAAA,QAAQ,EAAE;AACR;AACA,OAAC,CAACQ,CAAD,EAAIhC,CAAJ,CAAD,KAAY,CAAEgC,CAAC,GAAGA,CAAC,CAACD,GAAF,CAAMC,CAAC,IAAIA,CAAC,CAAC4B,IAAF,EAAX,CAAJ,CAA0B,OAAO,CAAC5B,CAAD,EAAIhC,CAAJ,CAAP,CAAe,CAF/C;AAGR6D,MAAAA,0BAA0B,CAAC7C,IAA3B,CAAgC,EAAEyC,UAAF,EAAcC,WAAd,EAAhC,CAHQ,CAHoC,EAAT,CAAvC;;;;AAUA;AACA;AACAtE,IAAAA,OAAO,GAAGA,OAAO,CAAC2C,GAAR,CAAYC,CAAC,IAAI,CAAE,OAAOA,CAAC,CAAC4B,IAAF,EAAP,CAAiB,CAApC,CAAV;AACA/B,IAAAA,OAAO,GAAGA,OAAO,CAACE,GAAR,CAAY/B,CAAC,IAAI,CAAjB,CAAV;;AAEA,WAAOZ,OAAO,CAACK,IAAR,CAAa+D,MAAb,CAAP;AACD,GApBD;AAqBD;;AAED;AACAvE,UAAU,CAAC6E,GAAX,CAAehF,MAAf;AACEsD,YAAY,CAAC,EAACE,UAAU,EAAE,KAAb,EAAD,CADd;;;AAIA;AACArD,UAAU,CAAC6E,GAAX,CAAehF,MAAM,GAAGC,kBAAxB;AACEqD,YAAY,CAAC,EAACE,UAAU,EAAE,IAAb,EAAD,CADd;;;AAIA;;;;;;;;;;;;;AAaO,SAASuB,0BAAT;AACLE,iBADK;AAEiB;AACtB;AACA,MAAI,CAAC3E,OAAD,EAAUyC,OAAV,IAAqBkC,iBAAzB;;AAEA;AACA;AACA,MAAIC,KAAK,GAAG5E,OAAO,IAAIA,OAAO,CAAC,CAAD,CAA9B;AACA,MAAI6E,IAAI,GAAG7E,OAAO,IAAIA,OAAO,CAACA,OAAO,CAACQ,MAAR,GAAiB,CAAlB,CAA7B;;AAEA;AACA,MAAIsE,SAAS,GAAG,EAAhB;;AAEA;AACA,MAAIF,KAAK,KAAK,EAAd,EAAkB,CAAE5E,OAAO,CAAC+E,KAAR,GAAiBtC,OAAO,CAACsC,KAAR,GAAiB;AACtD,MAAIF,IAAI,KAAK,EAAb,EAAiB,CAAE7E,OAAO,CAACgF,GAAR,GAAevC,OAAO,CAACuC,GAAR,GAAe;;AAEjDlD,EAAAA,OAAO,CAACd,GAAR,CAAY,WAAZ,EAAyBhB,OAAzB;;AAEA;AACA;AACA;AACA,MAAI,QAAQ,KAAKqE,UAAjB,EAA6B;AAC3BS,IAAAA,SAAS,CAACG,IAAV,CAAe,CAACjF,OAAD,EAAU,OAAV,CAAf;AACD;;AAED;AACA;AACA;AACA,MAAI,QAAQ,KAAKsE,WAAjB,EAA8B;AAC5BQ,IAAAA,SAAS,CAACG,IAAV,CAAe;AACb;AACAjF,IAAAA,OAAO,CAACkF,WAAR,CAAoB,CAACrC,CAAD,EAAGsC,CAAH,KAAS,CAAEtC,CAAC,CAACoC,IAAF,CAAOE,CAAP,EAAW,OAAOtC,CAAP,CAAU,CAApD,EAAsD,EAAtD,CAFa;AAGb,SAHa,CAAf;;AAKD;;AAED;AACA;AACA,OAAK,IAAIuC,KAAT,IAAkBN,SAAlB,EAA6B;AAC3B,QAAI,CAAChE,KAAD,EAAQuE,MAAR,IAAkBD,KAAtB;;AAEAtD,IAAAA,OAAO,CAACd,GAAR,CAAY,EAAZ,EAAgBF,KAAhB,EAAwB,QAAOuE,MAAO,KAAtC,EAA4CrF,OAA5C;;AAEA,SAAK,IAAII,MAAT,IAAmBU,KAAnB,EAA0B;AACxB,UAAI,QAAQiC,IAAR,CAAa3C,MAAb,CAAJ,EAA0B;AACxBJ,QAAAA,OAAO,CAACqF,MAAD,CAAP;AACA5C,QAAAA,OAAO,CAAC4C,MAAD,CAAP;AACAvD,QAAAA,OAAO,CAACd,GAAR,CAAa,GAAEqE,MAAO,QAAOjF,MAAO,GAApC;AACA;AACD,OALD;AAMK;AACH0B,QAAAA,OAAO,CAACd,GAAR,CAAa,kBAAiBZ,MAAO,GAArC;AACA;AACD;AACF;AACF;;AAED,SAAO,CAACJ,OAAD,EAAUyC,OAAV,CAAP;AACD;;AAED;;;;;;;;;AASO,SAASgB,sBAAT,CAAgCrD,MAAhC,EAAwD;AAC7D,MAAIJ,OAAO,GAAGI,MAAM,CAACsC,KAAP,CAAa,OAAb,CAAd;AACA;AACA,MAAI4C,KAAK,GAAG1C,CAAC,IAAIA,CAAC,CAACmB,OAAF,CAAU,WAAV,EAAuB,EAAvB,CAAjB;AACA,MAAIwB,KAAK,GAAG3C,CAAC,IAAIA,CAAC,CAACmB,OAAF,CAAU,aAAV,EAAyB,IAAzB,CAAjB;;AAEA;AACA;AACA,MAAI,CAACuB,KAAK,CAACtF,OAAO,CAAC,CAAD,CAAR,CAAL,CAAkBQ,MAAvB,EAA+B;AAC7BR,IAAAA,OAAO,CAACwF,MAAR,CAAe,CAAf,EAAkB,CAAlB;AACD;;AAED;AACA;AACExF,EAAAA,OAAO,CAACQ,MAAR;AACAR,EAAAA,OAAO,CAACA,OAAO,CAACQ,MAAR,GAAiB,CAAlB,CADP;AAEA,GAAC8E,KAAK,CAACtF,OAAO,CAACA,OAAO,CAACQ,MAAR,GAAiB,CAAlB,CAAR,CAAL,CAAmCA,MAHtC;AAIE;AACAR,IAAAA,OAAO,CAACwF,MAAR,CAAexF,OAAO,CAACQ,MAAR,GAAiB,CAAhC,EAAmC,CAAnC;AACD;;AAED,SAAOR,OAAO,CAACK,IAAR,CAAa,IAAb,CAAP;AACD;;AAED;;;;;;;;;;AAUO,SAASqD,iBAAT;AACL+B,MADK;AAE2B;AAChC,MAAI,CAACzF,OAAD,EAAUyC,OAAV,IAAqBgD,MAAzB;AACA,MAAIf,GAAG,GAAG,IAAIgB,GAAJ,CAAQjD,OAAR,CAAV;AACA,MAAIkD,MAAM,GAAG9B,IAAI,CAACC,GAAL,CAAS,GAAGrB,OAAZ,CAAb;;AAEAiC,EAAAA,GAAG,CAACkB,MAAJ,CAAWD,MAAX;;AAEA,SAAO,CAAC3F,OAAD,EAAUM,KAAK,CAACa,IAAN,CAAWuD,GAAX,CAAV,CAAP;AACD;;AAED;;;;;;;;;;;AAWO,SAASmB,cAAT;AACLJ,MADK;AAE2B;AAChC,SAAO,CAACA,MAAM,CAAC,CAAD,CAAP,EAAY,CAACK,MAAM,CAACC,gBAAR,CAAZ,CAAP;AACD;;AAED;;;;;;;AAOO,SAASvC,YAAT,CAAsBpD,MAAtB,EAA8C;AACnD,SAAOA,MAAP;AACD;;AAED;;;;;;;;;AASO,SAAS4F,YAAT;AACL5F,MADK;AAEL6F,KAFK;AAGLnF,KAHK;AAIG;AACR,SAAOO,IAAP;AACD;;AAED;;;;;;;;AAQO,SAASsC,aAAT;AACL8B,MADK;AAE2B;AAChC,SAAOA,MAAP;AACD;;AAED;;;AAGezB,M","sourceRoot":"src","sourcesContent":["// @flow\n\n// These constants can be discarded in the next major version where\n// customDedent is no longer present\nconst DEDENT = 1\nconst DEDENT_DROP_LOWEST = 2\nconst DEDENT_FULL = DEDENT | DEDENT_DROP_LOWEST\n\n// A short term solution to manage potential configurations for customDedent\n// in a low logic manner; i.e. without the need for excessive if statements\n// kill this in the next major revision\nconst variations: Map<Number, Function> = new Map()\n\n/**\n * One annoyance of working with tag functions is the conversion and inter-\n * weaving of the substitutions to get a string to modify in the first place.\n * This method does that and returns a string.\n *\n * Optionally you can specify a conversion function for each substitution\n * value. The signataure is `function (substitution): string`. It takes in a\n * substitution value, something in `${value}` within a template string and\n * receives a string as output. If none is supplied, a default function that\n * concatenates the value with an empty string is used. This will implicitly\n * invoke `.toString()` most of the time.\n *\n * @param {Array<string>} strings the strings that should be processed with\n * breaks wherever variable substitutions should occur. These map 1:1 to values\n * in `subs`\n * @param {Array<mixed>} subs the values that should be substituted into the\n * values found in\n * @param {Function} convert an optional function that can be used to coerce\n * the substitution to a form other than `sub.toString()`. It takes in the\n * substitution and should return a string value of some sort.\n */\nexport function handleSubstitutions(\n  strings: Array<string>,\n  subs: Array<mixed>,\n  convert: Function = (object) => '' + object\n): string {\n  let string = strings.join('');\n\n  if (subs && Array.isArray(subs) && subs.length) {\n    string = subs.reduce(\n      (prev, cur, i) => `${prev}${convert(cur)}${strings[i + 1]}`,\n      strings[0]\n    );\n  }\n\n  return string;\n}\n\n/**\n * Nearly identical to `cautiouslyApply`, this function works on an array of\n * items rather than a single item. The only other difference is that the\n * supplied functors receive the index of the item and the array the item is\n * contained within as second and third parameters, respectively.\n *\n * @param {Array<mixed>} array an array of values to apply each functor to\n * @param {Array<Function>} fns an array of `Function` objects that are to be\n * executed with the supplied `item` as its input and the new value as its\n * output. An error or fals\n * @param {boolean} log true if any errors caused by function execution should\n * be logged\n * @param {boolean} keepOldValueOnFalseyReturn if true and the functor returns\n * a falsey value, the value passed to it as a parameter is used instead\n * @return {Array<mixed>} a copy of the array passed as `array` but with\n * potentially modified internal values\n */\nexport function cautiouslyApplyEach(\n  array: Array<mixed>,\n  fns: Array<Function>,\n  log: boolean = true,\n  keepOldValueOnFalseyReturn: boolean = false\n): Array<mixed> {\n  let items = Array.from(array)\n\n  if (items && Array.isArray(items) && fns && Array.isArray(fns)) {\n    items.forEach((item, itemIndex, itemArray) => {\n      let newItem = item\n\n      fns.forEach(fn => {\n        try {\n          let bindFunctor = Array.isArray(fn) && fn[1]\n          let functor = bindFunctor\n            ? fn[0].bind(newItem)\n            : Array.isArray(fn) ? fn[0] : fn\n\n          if (keepOldValueOnFalseyReturn)\n            newItem = functor(newItem, itemIndex, itemArray) || newItem\n          else\n            newItem = functor(newItem, itemIndex, itemArray)\n        }\n        catch (error) {\n          if (log) {\n            console.error(error)\n          }\n        }\n      })\n\n      items[itemIndex] = newItem\n    })\n  }\n\n  return items\n}\n\n/**\n * Given an item that needs to be modified or replaced, the function takes\n * an array of functions to run in order, each receiving the last state of the\n * item. If an exception occurs during function execution the value passed is\n * the value that is kept.\n *\n * Optionally, when the function executes and returns the newly modified state\n * of the object in question, if that value is falsey it can be replaced with\n * the original value passed to the function instead. This is not true by\n * default\n *\n * `fns` is an array of functions, but any of the functions in the list are\n * actually a tuple matching [Function, boolean] **and** the boolean value is\n * true then the function within will be bound to the item it is operating on\n * as the `this` context for its execution before processing the value. It will\n * still receive the item as the first parameter as well.\n *\n * **NOTE: this will not work on big arrow functions**\n *\n * @param {mixed} item any JavaScript value\n * @param {Array<Function>} fns an array of `Function` objects that are to be\n * executed with the supplied `item` as its input and the new value as its\n * output. An error or fals\n * @param {boolean} log true if any errors caused by function execution should\n * be logged\n * @param {boolean} keepOldValueOnFalseyReturn if true and the functor returns\n * a falsey value, the value passed to it as a parameter is used instead\n * @return {mixed} the new value to replace the one supplied as `item`\n */\nexport function cautiouslyApply(\n  item: mixed,\n  fns: Array<Function|[Function, boolean]>,\n  log: boolean = true,\n  keepOldValueOnFalseyReturn: boolean = false\n): mixed {\n  if (fns && Array.isArray(fns)) {\n    fns.forEach(fn => {\n      try {\n        let bindFunctor = Array.isArray(fn) && fn[1]\n        let functor = bindFunctor\n          ? fn[0].bind(item)\n          : Array.isArray(fn) ? fn[0] : fn\n\n        if (keepOldValueOnFalseyReturn)\n          item = functor(item) || item\n        else\n          item = functor(item)\n      }\n      catch (error) {\n        if (log) {\n          console.error(error)\n        }\n      }\n    })\n  }\n\n  return item\n}\n\n/**\n * Measure indents is something that may be of use for any tag function. Its\n * purpose is to take a string, split it into separate lines and count the\n * leading whitespace of each line. Once finished, it returns an array of\n * two items; the list of strings and the matching list of indents which are\n * related to each other via index.\n *\n * The function also receives a config object which allows you to specify up\n * to three lists worth of functions.\n *\n * `preWork` is a list of functions that receive the following arguments in\n * each callback and are meant as a pluggable way to modify the initial string\n * programmatically by the consuming developer. Examples might be to prune\n * empty initial and final lines if they contain only whitespace\n *\n * ```\n * preWorkFn(string: string): string\n *\n *   - string: the supplied string to be modified by the function with the\n *     new version to be used as the returned value. If null or undefined is\n *     returned instead, the value supplied to the function will be used\n * ```\n *\n * `perLine` is list of functions that receive the following arguments in\n * each callback and are meant as a pluggable way to modify the line in\n * question. The expected return value is the newly modified string from which\n * to measure the indent of. Each item in the list will receive the modified\n * string returned by its predecessor. Effectively this is a map function\n *\n * ```\n * perLine(string: string, index: number, array: Array<string>): string\n * ```\n *\n * `postWork` is a list of functions that get called in order and receive\n * the final results in the form of an array containing two elements. The\n * first is the list of strings and the second is the list of measuredIndents.\n * The format of the supplied value (i.e. array of two arrays) is expected as\n * a return value. Failure to do so will likely end up as a bug someplace\n *\n * ```\n * postWork(\n *   array: Array<Array<string>, Array<number>>\n * ): Array<Array<string>, Array<number>>\n * ```\n *\n * All functions supplied to these arrays, if wrapped in an array with a\n * second parameter of true, will cause the function in question to be bound\n * with the item it is working on as the `this` context.\n *\n * @param {string} string see above\n * @param {Object} config see above\n * @param {RegExp} whitespace the defintion for whitespaced used within\n * @return {Array<Array<string>, Array<number>>} an array containing two\n * arrays; the first being an array of one line per index and the second being\n * an index matched array of numbered offsets indicating the amount of white\n * space that line is prefixed with\n */\nexport function measureIndents(\n  string: string|Array<string>,\n  config: Object = {\n    preWork: [],\n    perLine: [],\n    postWork: []\n  },\n  whitespace: RegExp = /[ \\t]/\n): Array<Array<string>, Array<number>> {\n  let regexp = new RegExp(`(^${whitespace.source}*)`)\n  let strings\n  let indents\n\n  if (Array.isArray(string)) {\n    string = string.join('\\n')\n  }\n\n  string = cautiouslyApply(string, config.preWork, true, true)\n  strings = string.split(/\\r?\\n/)\n  indents = strings.map((s, i, a) => {\n    let search\n\n    s = cautiouslyApply(s, config.perLine, true, false)\n\n    search = regexp.exec(s);\n    return search && search[1].length || 0;\n  });\n\n  return cautiouslyApply([strings, indents], config.postWork)\n}\n\n/**\n * The underpinning of `dedent()` is `customDedent()`. This function takes\n * an options object and returns a tag function. So direct usage would be\n * something like\n *\n * ```\n * let val = customDedent(options)`the string to work on`\n * ```\n *\n * Supported custom functionality currently supports \"dropping\" the lowest\n * level of indentation as long as the lowest indentation count makes up\n * less than half the overall indentation values. It does this by setting the\n * lowest values to be equal to the second lowest values.\n *\n * @param {Object} options\n *\n * @deprecated the options for customDedent seem to always be preferrable in\n * practice and as such, `dedent` and `gql` are simply aliases for the base\n * behavior in `customDedent` now. Expect `customDedent` to be removed in\n * future major revisions of `ne-tag-fns`\n */\nexport function customDedent(options: Object = { dropLowest: true }) {\n  let mask = DEDENT\n    | (options.dropLowest ? DEDENT_DROP_LOWEST : 0)\n\n  if (variations.has(mask)) {\n    return variations.get(mask)\n  }\n\n  return function (ss, ...subs) {\n    let [strings, indents] = measureIndents(\n      // handle the substitutions right off the bat, it will just make things\n      // easier all around\n      handleSubstitutions(ss, subs),\n\n      // pass in the handlers to strip empty head and tail strings and then\n      // drop the lowest value as this is often a requested feature\n      {\n        preWork: [\n          options.skipStrip\n            ? NOOP_PREWORK\n            : stripEmptyFirstAndLast\n        ],\n        postWork: [\n          options.dropLowest\n            ? dropLowestIndents\n            : NOOP_POSTWORK\n        ]\n      }\n    )\n\n    // count the minimal amount of shared leading whitespace\n    let excess = Math.min(...indents) || 0;\n\n    // if the excessive whitespace is greater than 0, remove the specified\n    // amount from each line\n    if (excess > 0) {\n      strings = strings.map(s => s.replace(/([ \\t]*)$/, ''));\n      strings = strings.map(s => s.replace(\n        new RegExp(`^[ \\t]{0,${excess}}`), ''\n      ));\n    }\n\n    // return a single joined string\n    return strings.join('\\n');\n  }\n}\n\n/**\n * This template tag function reduces any leading whitespace of each line of\n * the template string to the line with the least amount. If the first and/or\n * the last lines in the string are nothing but whitespace, then those lines\n * are omitted.\n *\n * @method dedent\n *\n * @param {Array<string>} strings the individual strings that appear around\n * the substitutions that follow in the parameter\n * @param {Array<mixed>} subs with the spread operator this becomes an array\n * of all the potential replacement values\n * @return {string} a combined and dedented string\n */\nexport function dedent(strings, ...subs) {\n  return customDedent({dropLowest: false})(\n    strings,\n    ...subs\n  )\n}\n\n/**\n * This template tag function reduces any leading whitespace of each line of\n * the template string to the line with the least amount. In some cases,\n * depending on how your source is written, dropping the lowest indent count\n * helps. This does that. So if you lines are indented `[2, 4, 4, 8]` then using\n * `dropLowest` instead of `dedent` makes it effectively `[4, 4, 4, 8]`. Like\n * `dedent', if the first and/or the last lines in the string are nothing but\n * whitespace, then those lines are omitted.\n *\n * @method dropLowest\n *\n * @param {Array<string>} strings the individual strings that appear around\n * the substitutions that follow in the parameter\n * @param {Array<mixed>} subs with the spread operator this becomes an array\n * of all the potential replacement values\n * @return {string} a combined and dedented string\n */\nexport function dropLowest(strings, ...subs) {\n  return customDedent({dropLowest: true})(\n    strings,\n    ...subs\n  )\n}\n\n/**\n * An alternate name for `dedentDropLowest` that can be used to trigger syntax\n * highlighting when used with GraphQL SDL/IDL strings in some IDEs and editors\n *\n * @type {Function}\n * @see #dedentDropLowest\n * @see #customDedent\n */\nexport const gql = dropLowest\n\n/**\n * Many times the desire to just make a single long string from several lines\n * of text is useful with tag functions. This provides that capability. And\n * before returning, each line found in the string will be trimmed of any\n * whitespace. Finally any remaining newlines other than the first and last, if\n * the first and last contain only whitespace, will be treated as a single\n * space\n *\n * @param {Array<string>} strings the strings that should be processed with\n * breaks wherever variable substitutions should occur. These map 1:1 to values\n * in `subs`\n * @param {Array<mixed>} subs the values that should be substituted into the\n * values found in\n * @return {string} a single string with spaces instead of line breaks and the\n * first and last lines removed if they contain only white space\n */\nexport function inline(ss, ...subs) {\n  return inlineJoin(' ')(ss, ...subs)\n}\n\n/**\n * `inlineJoin` is very similar to `inline` with the exception that a joinder\n * string can be supplied. For every newline encountered, rather than a space\n * the joint filler will be the value supplied. This type of tag function takes\n * a parameter and must be invoked at the time of usage, simply supplying the\n * function name before the tag string will not work as intended.\n *\n * Examples:\n * ```\n * let noSpaces = inlineJoin()`\n *   oneMississippi\n *   twoMississippi\n * ` == 'oneMississippitwoMississippi' // true\n *\n * or add dashes\n * let dashes = inlineJoin('-')`\n *   ASDFAS\n *   AQWERT\n *   ZXCVZX\n * ` == 'ASDFAS-AQWERT-ZXCVZX' // true\n * ```\n *\n * @method inlineJoin\n * @param {String} joiner a string to use when joining the values, defaults\n * to an empty string with no whitespace between each line\n * @return {Function} the actual tag function designed to combine the overall\n * tag string into a single line string with no carriage returns or newlines\n */\nexport function inlineJoin(\n  joiner = '',\n  allLeading = false,\n  allTrailing = false\n) {\n  return function _inlineJoiner(ss, ...subs) {\n    let string = handleSubstitutions(ss, ...subs)\n    console.log(`inlineJoin(${joiner}, ${allLeading}, ${allTrailing}) = '${string}'`)\n\n    let [strings, indents] = measureIndents(string, {\n      preWork: [],\n      perLine: [s => s.trim()],\n      postWork: [\n        // trimAllIndents,\n        ([s, i]) => { s = s.map(s => s.trim()); return [s, i] },\n        postStripEmptyFirstAndLast.bind({ allLeading, allTrailing })\n      ]\n    })\n\n    // if the excessive whitespace is greater than 0, remove the specified\n    // amount from each line\n    strings = strings.map(s => { return s.trim() })\n    indents = indents.map(i => 0)\n\n    return strings.join(joiner)\n  }\n}\n\n// Create cached variation with false for all options\nvariations.set(DEDENT,\n  customDedent({dropLowest: false})\n)\n\n// Create cached variation with true for dropping lowest\nvariations.set(DEDENT | DEDENT_DROP_LOWEST,\n  customDedent({dropLowest: true})\n)\n\n/**\n * A little bit of extra coverage to ensure that first and last\n * newlines, represented by empty strings in the strings array,\n * are stripped. If the function is bound to an object with\n * the parameter `allLeading` or `allTrailing`, then not only the\n * first and last but all leading and all trailing new lines will\n * be stripped. The config values are boolean so true will activate\n * and false will ignore additional leading and trailing values\n *\n * @method postStripEmptyFirstAndLast\n * @param {[type]} stringsAndIndents [description]\n * @return {[type]} [description]\n */\nexport function postStripEmptyFirstAndLast(\n  stringsAndIndents: [[string], [number]]\n): [[string], [number]] {\n  // Destructure the supplied stringsAndIndents property\n  let [strings, indents] = stringsAndIndents\n\n  // This function always removes first and last, so lets get those\n  // out of the way first\n  let first = strings && strings[0]\n  let last = strings && strings[strings.length - 1]\n\n  // This is for advanced usage of trimming all leading and trailing\n  let toProcess = []\n\n  // Trim the first and last if they are newlines represented by empty strings\n  if (first === '') { strings.shift(); indents.shift() }\n  if (last === '') { strings.pop(); indents.pop() }\n\n  console.log('strings: ', strings)\n\n  // Check to see if this function is bound to an object that has an allLeading\n  // property to signal we should remove all leading newlines, and not just the\n  // first one.\n  if (this && this.allLeading) {\n    toProcess.push([strings, 'shift'])\n  }\n\n  // Check to see if this function is bound to an object that has an\n  // allTrailing property to signal we should remove all trailing newlines,\n  // and not just the last one.\n  if (this && this.allTrailing) {\n    toProcess.push([\n      // Copy and reverse the strings array so we work backwards\n      strings.reduceRight((a,c) => { a.push(c); return a }, []),\n      'pop'\n    ])\n  }\n\n  // Each entry in toProcess will be an array to traverse and a function name\n  // to invoke on the actual strings array.\n  for (let value of toProcess) {\n    let [array, fnName] = value\n\n    console.log('', array, `and \"${fnName}\"\\n`, strings)\n\n    for (let string of array) {\n      if (/^\\s*$/.exec(string)) {\n        strings[fnName]()\n        indents[fnName]()\n        console.log(`${fnName}'ed \"${string}\"`)\n        continue\n      }\n      else {\n        console.log(`broke because \"${string}\"`)\n        break\n      }\n    }\n  }\n\n  return [strings, indents]\n}\n\n/**\n * A `preWork` functor for use with `measureIndents` that strips the first and\n * last lines from a given string if that string has nothing but whitespace. A\n * commonly desired functionality when working with multiline template strings\n *\n * @param  {string} string the string to parse\n * @return {string} a modified string missing bits that make up the first and/\n * or last lines **if** either of these lines are comprised of only whitespace\n */\nexport function stripEmptyFirstAndLast(string: string): string {\n  let strings = string.split(/\\r?\\n/)\n  // construct a small resuable function for trimming all initial whitespace\n  let trimL = s => s.replace(/^([ \\t]*)/, '');\n  let trimR = s => s.replace(/([ \\t]*)($)/, '$1');\n\n  // the first line is usually a misnomer, discount it if it is only\n  // whitespace\n  if (!trimL(strings[0]).length) {\n    strings.splice(0, 1);\n  }\n\n  // the same goes for the last line\n  if (\n    strings.length &&\n    strings[strings.length - 1] &&\n    !trimL(strings[strings.length - 1]).length\n  ) {\n    strings.splice(strings.length - 1, 1);\n  }\n\n  return strings.join('\\n')\n}\n\n/**\n * A `postWork` functor for use with `measureIndents` that will modify the\n * indents array to be an array missing its lowest number.\n *\n * @param {[Array<string>, Array<number>]} values the tuple containing the\n * modified strings and indent values\n * @return {[Array<string>, Array<number>]} returns a tuple containing an\n * unmodified set of strings and a modified indents array missing the lowest\n * number in the list\n */\nexport function dropLowestIndents(\n  values: [Array<string>, Array<number>]\n): [Array<string>, Array<number>] {\n  let [strings, indents] = values\n  let set = new Set(indents)\n  let lowest = Math.min(...indents)\n\n  set.delete(lowest)\n\n  return [strings, Array.from(set)]\n}\n\n/**\n * A `postWork` functor for use with `measureIndents` that will modify the\n * indents array to be a very large number so that all leading whitespace\n * is removed.\n *\n * @param {[Array<string>, Array<number>]} values the tuple containing the\n * modified strings and indent values\n * @return {[Array<string>, Array<number>]} returns a tuple containing an\n * unmodified set of strings and a modified indents array with a single large\n * number so that all leading whitespace is removed.\n */\nexport function trimAllIndents(\n  values: [Array<string>, Array<number>]\n): [Array<string>, Array<number>] {\n  return [values[0], [Number.MAX_SAFE_INTEGER]]\n}\n\n/**\n * A simple non operation `preWork` function that can make writing and reading\n * code that uses measureIndents easier to work with.\n *\n * @param {string} string any string value\n * @return {string} the value passsed in as `string`\n */\nexport function NOOP_PREWORK(string: string): string {\n  return string\n}\n\n/**\n * A simple non operation `perLine` function that can make writing and reading\n * code that uses measureIndents easier to work with.\n *\n * @param {string} string any string value\n * @param {number} index the index of `string` within `array`\n * @param {Array<string>} array the array containing `string`\n * @return {string} the value passsed in as `string`\n */\nexport function NOOP_PERLINE(\n  string: string,\n  index: number,\n  array: Array<string>\n): string {\n  return item\n}\n\n/**\n * A simple non operation `postWork` function that can make writing and reading\n * code that uses measureIndents easier to work with.\n *\n * @param {[Array<string>, Array<number>]} values the tuple containing the\n * modified strings and indent values\n * @return {[Array<string>, Array<number>]} the same value passed in as `values`\n */\nexport function NOOP_POSTWORK(\n  values: [Array<string>, Array<number>]\n): [Array<string>, Array<number>] {\n  return values\n}\n\n// Export the variations in the case someone needs to tweak the runtime\nexport { variations }\n\nexport default dedent;\n"],"file":"functions.js"}