{"version":3,"sources":["../src/functions.js"],"names":["DEDENT","DEDENT_DROP_LOWEST","DEDENT_FULL","variations","Map","handleSubstitutions","strings","subs","convert","object","string","join","Array","isArray","length","reduce","prev","cur","i","cautiouslyApplyEach","array","fns","log","keepOldValueOnFalseyReturn","items","from","forEach","item","itemIndex","itemArray","newItem","fn","bindFunctor","functor","bind","error","console","cautiouslyApply","measureIndents","config","preWork","perLine","postWork","whitespace","regexp","RegExp","source","indents","split","map","s","a","search","exec","customDedent","options","dropLowest","mask","has","get","ss","stripEmptyFirstAndLast","dropLowestIndents","NOOP_POSTWORK","excess","Math","min","replace","dedent","gql","inline","trim","trimAllIndents","set","trimL","trimR","splice","values","Set","lowest","delete","Number","MAX_SAFE_INTEGER","NOOP_PREWORK","NOOP_PERLINE","index"],"mappings":"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","sourceRoot":"src","sourcesContent":["// @flow\n\n// These constants can be discarded in the next major version where\n// customDedent is no longer present\nconst DEDENT = 1\nconst DEDENT_DROP_LOWEST = 2\nconst DEDENT_FULL = DEDENT | DEDENT_DROP_LOWEST\n\n// A short term solution to manage potential configurations for customDedent\n// in a low logic manner; i.e. without the need for excessive if statements\n// kill this in the next major revision\nconst variations: Map<Number, Function> = new Map()\n\n/**\n * One annoyance of working with tag functions is the conversion and inter-\n * weaving of the substitutions to get a string to modify in the first place.\n * This method does that and returns a string.\n *\n * Optionally you can specify a conversion function for each substitution\n * value. The signataure is `function (substitution): string`. It takes in a\n * substitution value, something in `${value}` within a template string and\n * receives a string as output. If none is supplied, a default function that\n * concatenates the value with an empty string is used. This will implicitly\n * invoke `.toString()` most of the time.\n *\n * @param {Array<string>} strings the strings that should be processed with\n * breaks wherever variable substitutions should occur. These map 1:1 to values\n * in `subs`\n * @param {Array<mixed>} subs the values that should be substituted into the\n * values found in\n * @param {Function} convert an optional function that can be used to coerce\n * the substitution to a form other than `sub.toString()`. It takes in the\n * substitution and should return a string value of some sort.\n */\nexport function handleSubstitutions(\n  strings: Array<string>,\n  subs: Array<mixed>,\n  convert: Function = (object) => '' + object\n): string {\n  let string = strings.join('');\n\n  if (subs && Array.isArray(subs) && subs.length) {\n    string = subs.reduce(\n      (prev, cur, i) => `${prev}${convert(cur)}${strings[i + 1]}`,\n      strings[0]\n    );\n  }\n\n  return string;\n}\n\n/**\n * Nearly identical to `cautiouslyApply`, this function works on an array of\n * items rather than a single item. The only other difference is that the\n * supplied functors receive the index of the item and the array the item is\n * contained within as second and third parameters, respectively.\n *\n * @param {Array<mixed>} array an array of values to apply each functor to\n * @param {Array<Function>} fns an array of `Function` objects that are to be\n * executed with the supplied `item` as its input and the new value as its\n * output. An error or fals\n * @param {boolean} log true if any errors caused by function execution should\n * be logged\n * @param {boolean} keepOldValueOnFalseyReturn if true and the functor returns\n * a falsey value, the value passed to it as a parameter is used instead\n * @return {Array<mixed>} a copy of the array passed as `array` but with\n * potentially modified internal values\n */\nexport function cautiouslyApplyEach(\n  array: Array<mixed>,\n  fns: Array<Function>,\n  log: boolean = true,\n  keepOldValueOnFalseyReturn: boolean = false\n): Array<mixed> {\n  let items = Array.from(array)\n\n  if (items && Array.isArray(items) && fns && Array.isArray(fns)) {\n    items.forEach((item, itemIndex, itemArray) => {\n      let newItem = item\n\n      fns.forEach(fn => {\n        try {\n          let bindFunctor = Array.isArray(fn) && fn[1]\n          let functor = bindFunctor\n            ? fn[0].bind(newItem)\n            : Array.isArray(fn) ? fn[0] : fn\n\n          if (keepOldValueOnFalseyReturn)\n            newItem = functor(newItem, itemIndex, itemArray) || newItem\n          else\n            newItem = functor(newItem, itemIndex, itemArray)\n        }\n        catch (error) {\n          if (log) {\n            console.error(error)\n          }\n        }\n      })\n\n      items[itemIndex] = newItem\n    })\n  }\n\n  return items\n}\n\n/**\n * Given an item that needs to be modified or replaced, the function takes\n * an array of functions to run in order, each receiving the last state of the\n * item. If an exception occurs during function execution the value passed is\n * the value that is kept.\n *\n * Optionally, when the function executes and returns the newly modified state\n * of the object in question, if that value is falsey it can be replaced with\n * the original value passed to the function instead. This is not true by\n * default\n *\n * `fns` is an array of functions, but any of the functions in the list are\n * actually a tuple matching [Function, boolean] **and** the boolean value is\n * true then the function within will be bound to the item it is operating on\n * as the `this` context for its execution before processing the value. It will\n * still receive the item as the first parameter as well.\n *\n * **NOTE: this will not work on big arrow functions**\n *\n * @param {mixed} item any JavaScript value\n * @param {Array<Function>} fns an array of `Function` objects that are to be\n * executed with the supplied `item` as its input and the new value as its\n * output. An error or fals\n * @param {boolean} log true if any errors caused by function execution should\n * be logged\n * @param {boolean} keepOldValueOnFalseyReturn if true and the functor returns\n * a falsey value, the value passed to it as a parameter is used instead\n * @return {mixed} the new value to replace the one supplied as `item`\n */\nexport function cautiouslyApply(\n  item: mixed,\n  fns: Array<Function|[Function, boolean]>,\n  log: boolean = true,\n  keepOldValueOnFalseyReturn: boolean = false\n): mixed {\n  if (fns && Array.isArray(fns)) {\n    fns.forEach(fn => {\n      try {\n        let bindFunctor = Array.isArray(fn) && fn[1]\n        let functor = bindFunctor\n          ? fn[0].bind(item)\n          : Array.isArray(fn) ? fn[0] : fn\n\n        if (keepOldValueOnFalseyReturn)\n          item = functor(item) || item\n        else\n          item = functor(item)\n      }\n      catch (error) {\n        if (log) {\n          console.error(error)\n        }\n      }\n    })\n  }\n\n  return item\n}\n\n/**\n * Measure indents is something that may be of use for any tag function. Its\n * purpose is to take a string, split it into separate lines and count the\n * leading whitespace of each line. Once finished, it returns an array of\n * two items; the list of strings and the matching list of indents which are\n * related to each other via index.\n *\n * The function also receives a config object which allows you to specify up\n * to three lists worth of functions.\n *\n * `preWork` is a list of functions that receive the following arguments in\n * each callback and are meant as a pluggable way to modify the initial string\n * programmatically by the consuming developer. Examples might be to prune\n * empty initial and final lines if they contain only whitespace\n *\n * ```\n * preWorkFn(string: string): string\n *\n *   - string: the supplied string to be modified by the function with the\n *     new version to be used as the returned value. If null or undefined is\n *     returned instead, the value supplied to the function will be used\n * ```\n *\n * `perLine` is list of functions that receive the following arguments in\n * each callback and are meant as a pluggable way to modify the line in\n * question. The expected return value is the newly modified string from which\n * to measure the indent of. Each item in the list will receive the modified\n * string returned by its predecessor. Effectively this is a map function\n *\n * ```\n * perLine(string: string, index: number, array: Array<string>): string\n * ```\n *\n * `postWork` is a list of functions that get called in order and receive\n * the final results in the form of an array containing two elements. The\n * first is the list of strings and the second is the list of measuredIndents.\n * The format of the supplied value (i.e. array of two arrays) is expected as\n * a return value. Failure to do so will likely end up as a bug someplace\n *\n * ```\n * postWork(\n *   array: Array<Array<string>, Array<number>>\n * ): Array<Array<string>, Array<number>>\n * ```\n *\n * All functions supplied to these arrays, if wrapped in an array with a\n * second parameter of true, will cause the function in question to be bound\n * with the item it is working on as the `this` context.\n *\n * @param {string} string see above\n * @param {Object} config see above\n * @param {RegExp} whitespace the defintion for whitespaced used within\n * @return {Array<Array<string>, Array<number>>} an array containing two\n * arrays; the first being an array of one line per index and the second being\n * an index matched array of numbered offsets indicating the amount of white\n * space that line is prefixed with\n */\nexport function measureIndents(\n  string: string|Array<string>,\n  config: Object = {\n    preWork: [],\n    perLine: [],\n    postWork: []\n  },\n  whitespace: RegExp = /[ \\t]/\n): Array<Array<string>, Array<number>> {\n  let regexp = new RegExp(`(^${whitespace.source}*)`)\n  let strings\n  let indents\n\n  if (Array.isArray(string)) {\n    string = string.join('\\n')\n  }\n\n  string = cautiouslyApply(string, config.preWork, true, true)\n  strings = string.split(/\\r?\\n/)\n  indents = strings.map((s, i, a) => {\n    let search\n\n    s = cautiouslyApply(s, config.perLine, true, false)\n\n    search = regexp.exec(s);\n    return search && search[1].length || 0;\n  });\n\n  return cautiouslyApply([strings, indents], config.postWork)\n}\n\n/**\n * The underpinning of `dedent()` is `customDedent()`. This function takes\n * an options object and returns a tag function. So direct usage would be\n * something like\n *\n * ```\n * let val = customDedent(options)`the string to work on`\n * ```\n *\n * Supported custom functionality currently supports \"dropping\" the lowest\n * level of indentation as long as the lowest indentation count makes up\n * less than half the overall indentation values. It does this by setting the\n * lowest values to be equal to the second lowest values.\n *\n * @param {Object} options\n *\n * @deprecated the options for customDedent seem to always be preferrable in\n * practice and as such, `dedent` and `gql` are simply aliases for the base\n * behavior in `customDedent` now. Expect `customDedent` to be removed in\n * future major revisions of `ne-tag-fns`\n */\nexport function customDedent(options: Object = { dropLowest: true }) {\n  let mask = DEDENT\n    | (options.dropLowest ? DEDENT_DROP_LOWEST : 0)\n\n  if (variations.has(mask)) {\n    return variations.get(mask)\n  }\n\n  return function (ss, ...subs) {\n    let [strings, indents] = measureIndents(\n      // handle the substitutions right off the bat, it will just make things\n      // easier all around\n      handleSubstitutions(ss, subs),\n\n      // pass in the handlers to strip empty head and tail strings and then\n      // drop the lowest value as this is often a requested feature\n      {\n        preWork: [stripEmptyFirstAndLast],\n        postWork: [\n          options.dropLowest\n            ? dropLowestIndents\n            : NOOP_POSTWORK\n        ]\n      }\n    )\n\n    // count the minimal amount of shared leading whitespace\n    let excess = Math.min(...indents) || 0;\n\n    // if the excessive whitespace is greater than 0, remove the specified\n    // amount from each line\n    if (excess > 0) {\n      strings = strings.map(s => s.replace(/([ \\t]*)$/, ''));\n      strings = strings.map(s => s.replace(\n        new RegExp(`^[ \\t]{0,${excess}}`), ''\n      ));\n    }\n\n    // return a single joined string\n    return strings.join('\\n');\n  }\n}\n\n/**\n * This template tag function reduces any leading whitespace of each line of\n * the template string to the line with the least amount. If the first and/or\n * the last lines in the string are nothing but whitespace, then those lines\n * are omitted.\n *\n * @method dedent\n *\n * @param {Array<string>} strings the individual strings that appear around\n * the substitutions that follow in the parameter\n * @param {Array<mixed>} subs with the spread operator this becomes an array\n * of all the potential replacement values\n * @return {string} a combined and dedented string\n */\nexport function dedent(strings, ...subs) {\n  return customDedent({dropLowest: false})(\n    strings,\n    ...subs\n  )\n}\n\n/**\n * This template tag function reduces any leading whitespace of each line of\n * the template string to the line with the least amount. In some cases,\n * depending on how your source is written, dropping the lowest indent count\n * helps. This does that. So if you lines are indented `[2, 4, 4, 8]` then using\n * `dropLowest` instead of `dedent` makes it effectively `[4, 4, 4, 8]`. Like\n * `dedent', if the first and/or the last lines in the string are nothing but\n * whitespace, then those lines are omitted.\n *\n * @method dropLowest\n *\n * @param {Array<string>} strings the individual strings that appear around\n * the substitutions that follow in the parameter\n * @param {Array<mixed>} subs with the spread operator this becomes an array\n * of all the potential replacement values\n * @return {string} a combined and dedented string\n */\nexport function dropLowest(strings, ...subs) {\n  return customDedent({dropLowest: true})(\n    strings,\n    ...subs\n  )\n}\n\n/**\n * An alternate name for `dedentDropLowest` that can be used to trigger syntax\n * highlighting when used with GraphQL SDL/IDL strings in some IDEs and editors\n *\n * @type {Function}\n * @see #dedentDropLowest\n * @see #customDedent\n */\nexport const gql = dropLowest\n\n/**\n * Many times the desire to just make a single long string from several lines\n * of text is useful with tag functions. This provides that capability. And\n * before returning, each line found in the string will be trimmed of any\n * whitespace. Finally any remaining newlines other than the first and last, if\n * the first and last contain only whitespace, will be treated as a single\n * space\n *\n * @param {Array<string>} strings the strings that should be processed with\n * breaks wherever variable substitutions should occur. These map 1:1 to values\n * in `subs`\n * @param {Array<mixed>} subs the values that should be substituted into the\n * values found in\n * @return {string} a single string with spaces instead of line breaks and the\n * first and last lines removed if they contain only white space\n */\nexport function inline(ss, ...subs) {\n  let string = handleSubstitutions(ss, ...subs)\n  let [strings, indents] = measureIndents(string, {\n    preWork: [stripEmptyFirstAndLast],\n    perLine: [s => s.trim()],\n    postWork: [trimAllIndents]\n  })\n\n  // count the minimal amount of shared leading whitespace\n  let excess = Math.min(...indents) || 0;\n\n  // if the excessive whitespace is greater than 0, remove the specified\n  // amount from each line\n  if (excess > 0) {\n    strings = strings.map(s => s.replace(/([ \\t]*)$/, ''));\n    strings = strings.map(s => s.replace(\n      new RegExp(`^[ \\t]{0,${excess}}`), ''\n    ));\n  }\n\n  return strings.join(' ')\n}\n\n// Create cached variation with false for all options\nvariations.set(DEDENT,\n  customDedent({dropLowest: false})\n)\n\n// Create cached variation with true for dropping lowest\nvariations.set(DEDENT | DEDENT_DROP_LOWEST,\n  customDedent({dropLowest: true})\n)\n\n/**\n * A `preWork` functor for use with `measureIndents` that strips the first and\n * last lines from a given string if that string has nothing but whitespace. A\n * commonly desired functionality when working with multiline template strings\n *\n * @param  {string} string the string to parse\n * @return {string} a modified string missing bits that make up the first and/\n * or last lines **if** either of these lines are comprised of only whitespace\n */\nexport function stripEmptyFirstAndLast(string: string): string {\n  let strings = string.split(/\\r?\\n/)\n  // construct a small resuable function for trimming all initial whitespace\n  let trimL = s => s.replace(/^([ \\t]*)/, '');\n  let trimR = s => s.replace(/([ \\t]*)($)/, '$1');\n\n  // the first line is usually a misnomer, discount it if it is only\n  // whitespace\n  if (!trimL(strings[0]).length) {\n    strings.splice(0, 1);\n  }\n\n  // the same goes for the last line\n  if (\n    strings.length && \n    strings[strings.length - 1] && \n    !trimL(strings[strings.length - 1]).length\n  ) {\n    strings.splice(strings.length - 1, 1);\n  }\n\n  return strings.join('\\n')\n}\n\n/**\n * A `postWork` functor for use with `measureIndents` that will modify the\n * indents array to be an array missing its lowest number.\n *\n * @param {[Array<string>, Array<number>]} values the tuple containing the\n * modified strings and indent values\n * @return {[Array<string>, Array<number>]} returns a tuple containing an\n * unmodified set of strings and a modified indents array missing the lowest\n * number in the list\n */\nexport function dropLowestIndents(\n  values: [Array<string>, Array<number>]\n): [Array<string>, Array<number>] {\n  let [strings, indents] = values\n  let set = new Set(indents)\n  let lowest = Math.min(...indents)\n\n  set.delete(lowest)\n\n  return [strings, Array.from(set)]\n}\n\n/**\n * A `postWork` functor for use with `measureIndents` that will modify the\n * indents array to be a very large number so that all leading whitespace\n * is removed.\n *\n * @param {[Array<string>, Array<number>]} values the tuple containing the\n * modified strings and indent values\n * @return {[Array<string>, Array<number>]} returns a tuple containing an\n * unmodified set of strings and a modified indents array with a single large\n * number so that all leading whitespace is removed.\n */\nexport function trimAllIndents(\n  values: [Array<string>, Array<number>]\n): [Array<string>, Array<number>] {\n  return [values[0], [Number.MAX_SAFE_INTEGER]]\n}\n\n/**\n * A simple non operation `preWork` function that can make writing and reading\n * code that uses measureIndents easier to work with.\n *\n * @param {string} string any string value\n * @return {string} the value passsed in as `string`\n */\nexport function NOOP_PREWORK(string: string): string {\n  return string\n}\n\n/**\n * A simple non operation `perLine` function that can make writing and reading\n * code that uses measureIndents easier to work with.\n *\n * @param {string} string any string value\n * @param {number} index the index of `string` within `array`\n * @param {Array<string>} array the array containing `string`\n * @return {string} the value passsed in as `string`\n */\nexport function NOOP_PERLINE(\n  string: string,\n  index: number,\n  array: Array<string>\n): string {\n  return item\n}\n\n/**\n * A simple non operation `postWork` function that can make writing and reading\n * code that uses measureIndents easier to work with.\n *\n * @param {[Array<string>, Array<number>]} values the tuple containing the\n * modified strings and indent values\n * @return {[Array<string>, Array<number>]} the same value passed in as `values`\n */\nexport function NOOP_POSTWORK(\n  values: [Array<string>, Array<number>]\n): [Array<string>, Array<number>] {\n  return values\n}\n\n// Export the variations in the case someone needs to tweak the runtime\nexport { variations }\n\nexport default dedent;\n"],"file":"functions.js"}