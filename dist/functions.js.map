{"version":3,"sources":["../src/functions.js"],"names":["handleSubstitutions","cautiouslyApplyEach","cautiouslyApply","measureIndents","customDedent","dedent","dropLowest","inline","stripEmptyFirstAndLast","dropLowestIndents","trimAllIndents","NOOP_PREWORK","NOOP_PERLINE","NOOP_POSTWORK","DEDENT","DEDENT_DROP_LOWEST","DEDENT_FULL","variations","Map","strings","subs","convert","object","string","join","Array","isArray","length","reduce","prev","cur","i","array","fns","log","keepOldValueOnFalseyReturn","items","from","forEach","item","itemIndex","itemArray","newItem","bindFunctor","fn","functor","bind","error","console","config","preWork","perLine","postWork","whitespace","regexp","RegExp","source","indents","split","map","s","a","search","exec","options","mask","has","get","ss","excess","Math","min","replace","gql","trim","set","trimL","trimR","splice","values","Set","lowest","delete","Number","MAX_SAFE_INTEGER","index"],"mappings":"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","file":"functions.js","sourceRoot":"src","sourcesContent":["// @flow\n\n// These constants can be discarded in the next major version where\n// customDedent is no longer present\nconst DEDENT = 1\nconst DEDENT_DROP_LOWEST = 2\nconst DEDENT_FULL = DEDENT | DEDENT_DROP_LOWEST\n\n// A short term solution to manage potential configurations for customDedent\n// in a low logic manner; i.e. without the need for excessive if statements\n// kill this in the next major revision\nconst variations: Map<Number, Function> = new Map()\n\n/**\n * One annoyance of working with tag functions is the conversion and inter-\n * weaving of the substitutions to get a string to modify in the first place.\n * This method does that and returns a string.\n *\n * Optionally you can specify a conversion function for each substitution\n * value. The signataure is `function (substitution): string`. It takes in a\n * substitution value, something in `${value}` within a template string and\n * receives a string as output. If none is supplied, a default function that\n * concatenates the value with an empty string is used. This will implicitly\n * invoke `.toString()` most of the time.\n *\n * @param {Array<string>} strings the strings that should be processed with\n * breaks wherever variable substitutions should occur. These map 1:1 to values\n * in `subs`\n * @param {Array<mixed>} subs the values that should be substituted into the\n * values found in\n * @param {Function} convert an optional function that can be used to coerce\n * the substitution to a form other than `sub.toString()`. It takes in the\n * substitution and should return a string value of some sort.\n */\nexport function handleSubstitutions(\n  strings: Array<string>,\n  subs: Array<mixed>,\n  convert: Function = (object) => '' + object\n): string {\n  let string = strings.join('');\n\n  if (subs && Array.isArray(subs) && subs.length) {\n    string = subs.reduce(\n      (prev, cur, i) => `${prev}${convert(cur)}${strings[i + 1]}`,\n      strings[0]\n    );\n  }\n\n  return string;\n}\n\n/**\n * Nearly identical to `cautiouslyApply`, this function works on an array of\n * items rather than a single item. The only other difference is that the\n * supplied functors receive the index of the item and the array the item is\n * contained within as second and third parameters, respectively.\n *\n * @param {Array<mixed>} array an array of values to apply each functor to\n * @param {Array<Function>} fns an array of `Function` objects that are to be\n * executed with the supplied `item` as its input and the new value as its\n * output. An error or fals\n * @param {boolean} log true if any errors caused by function execution should\n * be logged\n * @param {boolean} keepOldValueOnFalseyReturn if true and the functor returns\n * a falsey value, the value passed to it as a parameter is used instead\n * @return {Array<mixed>} a copy of the array passed as `array` but with\n * potentially modified internal values\n */\nexport function cautiouslyApplyEach(\n  array: Array<mixed>,\n  fns: Array<Function>,\n  log: boolean = true,\n  keepOldValueOnFalseyReturn: boolean = false\n): Array<mixed> {\n  let items = Array.from(array)\n\n  if (items && Array.isArray(items) && fns && Array.isArray(fns)) {\n    items.forEach((item, itemIndex, itemArray) => {\n      let newItem = item\n\n      fns.forEach(fn => {\n        try {\n          let bindFunctor = Array.isArray(fn) && fn[1]\n          let functor = bindFunctor\n            ? fn[0].bind(newItem)\n            : Array.isArray(fn) ? fn[0] : fn\n\n          if (keepOldValueOnFalseyReturn)\n            newItem = functor(newItem, itemIndex, itemArray) || newItem\n          else\n            newItem = functor(newItem, itemIndex, itemArray)\n        }\n        catch (error) {\n          if (log) {\n            console.error(error)\n          }\n        }\n      })\n\n      items[itemIndex] = newItem\n    })\n  }\n\n  return items\n}\n\n/**\n * Given an item that needs to be modified or replaced, the function takes\n * an array of functions to run in order, each receiving the last state of the\n * item. If an exception occurs during function execution the value passed is\n * the value that is kept.\n *\n * Optionally, when the function executes and returns the newly modified state\n * of the object in question, if that value is falsey it can be replaced with\n * the original value passed to the function instead. This is not true by\n * default\n *\n * `fns` is an array of functions, but any of the functions in the list are\n * actually a tuple matching [Function, boolean] **and** the boolean value is\n * true then the function within will be bound to the item it is operating on\n * as the `this` context for its execution before processing the value. It will\n * still receive the item as the first parameter as well.\n *\n * **NOTE: this will not work on big arrow functions**\n *\n * @param {mixed} item any JavaScript value\n * @param {Array<Function>} fns an array of `Function` objects that are to be\n * executed with the supplied `item` as its input and the new value as its\n * output. An error or fals\n * @param {boolean} log true if any errors caused by function execution should\n * be logged\n * @param {boolean} keepOldValueOnFalseyReturn if true and the functor returns\n * a falsey value, the value passed to it as a parameter is used instead\n * @return {mixed} the new value to replace the one supplied as `item`\n */\nexport function cautiouslyApply(\n  item: mixed,\n  fns: Array<Function|[Function, boolean]>,\n  log: boolean = true,\n  keepOldValueOnFalseyReturn: boolean = false\n): mixed {\n  if (fns && Array.isArray(fns)) {\n    fns.forEach(fn => {\n      try {\n        let bindFunctor = Array.isArray(fn) && fn[1]\n        let functor = bindFunctor\n          ? fn[0].bind(item)\n          : Array.isArray(fn) ? fn[0] : fn\n\n        if (keepOldValueOnFalseyReturn)\n          item = functor(item) || item\n        else\n          item = functor(item)\n      }\n      catch (error) {\n        if (log) {\n          console.error(error)\n        }\n      }\n    })\n  }\n\n  return item\n}\n\n/**\n * Measure indents is something that may be of use for any tag function. Its\n * purpose is to take a string, split it into separate lines and count the\n * leading whitespace of each line. Once finished, it returns an array of\n * two items; the list of strings and the matching list of indents which are\n * related to each other via index.\n *\n * The function also receives a config object which allows you to specify up\n * to three lists worth of functions.\n *\n * `preWork` is a list of functions that receive the following arguments in\n * each callback and are meant as a pluggable way to modify the initial string\n * programmatically by the consuming developer. Examples might be to prune\n * empty initial and final lines if they contain only whitespace\n *\n * ```\n * preWorkFn(string: string): string\n *\n *   - string: the supplied string to be modified by the function with the\n *     new version to be used as the returned value. If null or undefined is\n *     returned instead, the value supplied to the function will be used\n * ```\n *\n * `perLine` is list of functions that receive the following arguments in\n * each callback and are meant as a pluggable way to modify the line in\n * question. The expected return value is the newly modified string from which\n * to measure the indent of. Each item in the list will receive the modified\n * string returned by its predecessor. Effectively this is a map function\n *\n * ```\n * perLine(string: string, index: number, array: Array<string>): string\n * ```\n *\n * `postWork` is a list of functions that get called in order and receive\n * the final results in the form of an array containing two elements. The\n * first is the list of strings and the second is the list of measuredIndents.\n * The format of the supplied value (i.e. array of two arrays) is expected as\n * a return value. Failure to do so will likely end up as a bug someplace\n *\n * ```\n * postWork(\n *   array: Array<Array<string>, Array<number>>\n * ): Array<Array<string>, Array<number>>\n * ```\n *\n * All functions supplied to these arrays, if wrapped in an array with a\n * second parameter of true, will cause the function in question to be bound\n * with the item it is working on as the `this` context.\n *\n * @param {string} string see above\n * @param {Object} config see above\n * @param {RegExp} whitespace the defintion for whitespaced used within\n * @return {Array<Array<string>, Array<number>>} an array containing two\n * arrays; the first being an array of one line per index and the second being\n * an index matched array of numbered offsets indicating the amount of white\n * space that line is prefixed with\n */\nexport function measureIndents(\n  string: string|Array<string>,\n  config: Object = {\n    preWork: [],\n    perLine: [],\n    postWork: []\n  },\n  whitespace: RegExp = /[ \\t]/\n): Array<Array<string>, Array<number>> {\n  let regexp = new RegExp(`(^${whitespace.source}*)`)\n  let strings\n  let indents\n\n  if (Array.isArray(string)) {\n    string = string.join('\\n')\n  }\n\n  string = cautiouslyApply(string, config.preWork, true, true)\n  strings = string.split(/\\r?\\n/)\n  indents = strings.map((s, i, a) => {\n    let search\n\n    s = cautiouslyApply(s, config.perLine, true, false)\n\n    search = regexp.exec(s);\n    return search && search[1].length || 0;\n  });\n\n  return cautiouslyApply([strings, indents], config.postWork)\n}\n\n/**\n * The underpinning of `dedent()` is `customDedent()`. This function takes\n * an options object and returns a tag function. So direct usage would be\n * something like\n *\n * ```\n * let val = customDedent(options)`the string to work on`\n * ```\n *\n * Supported custom functionality currently supports \"dropping\" the lowest\n * level of indentation as long as the lowest indentation count makes up\n * less than half the overall indentation values. It does this by setting the\n * lowest values to be equal to the second lowest values.\n *\n * @param {Object} options\n *\n * @deprecated the options for customDedent seem to always be preferrable in\n * practice and as such, `dedent` and `gql` are simply aliases for the base\n * behavior in `customDedent` now. Expect `customDedent` to be removed in\n * future major revisions of `ne-tag-fns`\n */\nexport function customDedent(options: Object = { dropLowest: true }) {\n  let mask = DEDENT\n    | (options.dropLowest ? DEDENT_DROP_LOWEST : 0)\n\n  if (variations.has(mask)) {\n    return variations.get(mask)\n  }\n\n  return function (ss, ...subs) {\n    let [strings, indents] = measureIndents(\n      // handle the substitutions right off the bat, it will just make things\n      // easier all around\n      handleSubstitutions(ss, subs),\n\n      // pass in the handlers to strip empty head and tail strings and then\n      // drop the lowest value as this is often a requested feature\n      {\n        preWork: [stripEmptyFirstAndLast],\n        postWork: [\n          options.dropLowest\n            ? dropLowestIndents\n            : NOOP_POSTWORK\n        ]\n      }\n    )\n\n    // count the minimal amount of shared leading whitespace\n    let excess = Math.min(...indents) || 0;\n\n    // if the excessive whitespace is greater than 0, remove the specified\n    // amount from each line\n    if (excess > 0) {\n      strings = strings.map(s => s.replace(/([ \\t]*)$/, ''));\n      strings = strings.map(s => s.replace(\n        new RegExp(`^[ \\t]{0,${excess}}`), ''\n      ));\n    }\n\n    // return a single joined string\n    return strings.join('\\n');\n  }\n}\n\n/**\n * This template tag function reduces any leading whitespace of each line of\n * the template string to the line with the least amount. If the first and/or\n * the last lines in the string are nothing but whitespace, then those lines\n * are omitted.\n *\n * @method dedent\n *\n * @param {Array<string>} strings the individual strings that appear around\n * the substitutions that follow in the parameter\n * @param {Array<mixed>} subs with the spread operator this becomes an array\n * of all the potential replacement values\n * @return {string} a combined and dedented string\n */\nexport function dedent(strings, ...subs) {\n  return customDedent({dropLowest: false})(\n    strings,\n    ...subs\n  )\n}\n\n/**\n * This template tag function reduces any leading whitespace of each line of\n * the template string to the line with the least amount. In some cases,\n * depending on how your source is written, dropping the lowest indent count\n * helps. This does that. So if you lines are indented `[2, 4, 4, 8]` then using\n * `dropLowest` instead of `dedent` makes it effectively `[4, 4, 4, 8]`. Like\n * `dedent', if the first and/or the last lines in the string are nothing but\n * whitespace, then those lines are omitted.\n *\n * @method dropLowest\n *\n * @param {Array<string>} strings the individual strings that appear around\n * the substitutions that follow in the parameter\n * @param {Array<mixed>} subs with the spread operator this becomes an array\n * of all the potential replacement values\n * @return {string} a combined and dedented string\n */\nexport function dropLowest(strings, ...subs) {\n  return customDedent({dropLowest: true})(\n    strings,\n    ...subs\n  )\n}\n\n/**\n * An alternate name for `dedentDropLowest` that can be used to trigger syntax\n * highlighting when used with GraphQL SDL/IDL strings in some IDEs and editors\n *\n * @type {Function}\n * @see #dedentDropLowest\n * @see #customDedent\n */\nexport const gql = dropLowest\n\n/**\n * Many times the desire to just make a single long string from several lines\n * of text is useful with tag functions. This provides that capability. And\n * before returning, each line found in the string will be trimmed of any\n * whitespace. Finally any remaining newlines other than the first and last, if\n * the first and last contain only whitespace, will be treated as a single\n * space\n *\n * @param {Array<string>} strings the strings that should be processed with\n * breaks wherever variable substitutions should occur. These map 1:1 to values\n * in `subs`\n * @param {Array<mixed>} subs the values that should be substituted into the\n * values found in\n * @return {string} a single string with spaces instead of line breaks and the\n * first and last lines removed if they contain only white space\n */\nexport function inline(ss, ...subs) {\n  let string = handleSubstitutions(ss, ...subs)\n  let [strings, indents] = measureIndents(string, {\n    preWork: [stripEmptyFirstAndLast],\n    perLine: [s => s.trim()],\n    postWork: [trimAllIndents]\n  })\n\n  // count the minimal amount of shared leading whitespace\n  let excess = Math.min(...indents) || 0;\n\n  // if the excessive whitespace is greater than 0, remove the specified\n  // amount from each line\n  if (excess > 0) {\n    strings = strings.map(s => s.replace(/([ \\t]*)$/, ''));\n    strings = strings.map(s => s.replace(\n      new RegExp(`^[ \\t]{0,${excess}}`), ''\n    ));\n  }\n\n  return strings.join(' ')\n}\n\n// Create cached variation with false for all options\nvariations.set(DEDENT,\n  customDedent({dropLowest: false})\n)\n\n// Create cached variation with true for dropping lowest\nvariations.set(DEDENT | DEDENT_DROP_LOWEST,\n  customDedent({dropLowest: true})\n)\n\n/**\n * A `preWork` functor for use with `measureIndents` that strips the first and\n * last lines from a given string if that string has nothing but whitespace. A\n * commonly desired functionality when working with multiline template strings\n *\n * @param  {string} string the string to parse\n * @return {string} a modified string missing bits that make up the first and/\n * or last lines **if** either of these lines are comprised of only whitespace\n */\nexport function stripEmptyFirstAndLast(string: string): string {\n  let strings = string.split(/\\r?\\n/)\n  // construct a small resuable function for trimming all initial whitespace\n  let trimL = s => s.replace(/^([ \\t]*)/, '');\n  let trimR = s => s.replace(/([ \\t]*)($)/, '$1');\n\n  // the first line is usually a misnomer, discount it if it is only\n  // whitespace\n  if (!trimL(strings[0]).length) {\n    strings.splice(0, 1);\n  }\n\n  // the same goes for the last line\n  if (!trimL(strings[strings.length - 1]).length) {\n    strings.splice(strings.length - 1, 1);\n  }\n\n  return strings.join('\\n')\n}\n\n/**\n * A `postWork` functor for use with `measureIndents` that will modify the\n * indents array to be an array missing its lowest number.\n *\n * @param {[Array<string>, Array<number>]} values the tuple containing the\n * modified strings and indent values\n * @return {[Array<string>, Array<number>]} returns a tuple containing an\n * unmodified set of strings and a modified indents array missing the lowest\n * number in the list\n */\nexport function dropLowestIndents(\n  values: [Array<string>, Array<number>]\n): [Array<string>, Array<number>] {\n  let [strings, indents] = values\n  let set = new Set(indents)\n  let lowest = Math.min(...indents)\n\n  set.delete(lowest)\n\n  return [strings, Array.from(set)]\n}\n\n/**\n * A `postWork` functor for use with `measureIndents` that will modify the\n * indents array to be a very large number so that all leading whitespace\n * is removed.\n *\n * @param {[Array<string>, Array<number>]} values the tuple containing the\n * modified strings and indent values\n * @return {[Array<string>, Array<number>]} returns a tuple containing an\n * unmodified set of strings and a modified indents array with a single large\n * number so that all leading whitespace is removed.\n */\nexport function trimAllIndents(\n  values: [Array<string>, Array<number>]\n): [Array<string>, Array<number>] {\n  return [values[0], [Number.MAX_SAFE_INTEGER]]\n}\n\n/**\n * A simple non operation `preWork` function that can make writing and reading\n * code that uses measureIndents easier to work with.\n *\n * @param {string} string any string value\n * @return {string} the value passsed in as `string`\n */\nexport function NOOP_PREWORK(string: string): string {\n  return string\n}\n\n/**\n * A simple non operation `perLine` function that can make writing and reading\n * code that uses measureIndents easier to work with.\n *\n * @param {string} string any string value\n * @param {number} index the index of `string` within `array`\n * @param {Array<string>} array the array containing `string`\n * @return {string} the value passsed in as `string`\n */\nexport function NOOP_PERLINE(\n  string: string,\n  index: number,\n  array: Array<string>\n): string {\n  return item\n}\n\n/**\n * A simple non operation `postWork` function that can make writing and reading\n * code that uses measureIndents easier to work with.\n *\n * @param {[Array<string>, Array<number>]} values the tuple containing the\n * modified strings and indent values\n * @return {[Array<string>, Array<number>]} the same value passed in as `values`\n */\nexport function NOOP_POSTWORK(\n  values: [Array<string>, Array<number>]\n): [Array<string>, Array<number>] {\n  return values\n}\n\n// Export the variations in the case someone needs to tweak the runtime\nexport { variations }\n\nexport default dedent;\n"]}