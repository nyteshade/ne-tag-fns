{"version":3,"sources":["../src/functions.js"],"names":["handleSubstitutions","customDedent","dedent","strings","subs","convert","object","string","join","Array","isArray","length","reduce","prev","cur","i","options","dropLowest","undefined","split","trimL","s","replace","trimR","splice","indents","map","search","exec","isFn","obj","lowest","Math","min","occurences","filter","o","nextLowest","concat","test","array","count","excess","RegExp"],"mappings":"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","file":"functions.js","sourceRoot":"src","sourcesContent":["// @flow\n\n/**\n * One annoyance of working with tag functions is the conversion and inter-\n * weaving of the substitutions to get a string to modify in the first place.\n * This method does that and returns a string.\n *\n * Optionally you can specify a conversion function for each substitution\n * value. The signataure is `function (substitution): string`. It takes in a\n * substitution value, something in `${value}` within a template string and\n * receives a string as output. If none is supplied, a default function that\n * concatenates the value with an empty string is used. This will implicitly\n * invoke `.toString()` most of the time.\n *\n * @param {Array<string>} strings the strings that should be processed with\n * breaks wherever variable substitutions should occur. These map 1:1 to values\n * in `subs`\n * @param {Array<mixed>} subs the values that should be substituted into the\n * values found in\n * @param {Function} convert an optional function that can be used to coerce\n * the substitution to a form other than `sub.toString()`. It takes in the\n * substitution and should return a string value of some sort.\n */\nexport function handleSubstitutions(\n  strings: Array<string>,\n  subs: Array<mixed>,\n  convert: Function = (object) => '' + object\n): string {\n  let string = strings.join('');\n\n  if (subs && Array.isArray(subs) && subs.length) {\n    string = subs.reduce(\n      (prev, cur, i) => `${prev}${convert(cur)}${strings[i + 1]}`,\n      strings[0]\n    );\n  }\n\n  return string;\n}\n\n/**\n * The underpinning of `dedent()` is `customDedent()`. This function takes\n * an options object and returns a tag function. So direct usage would be\n * something like\n *\n * ```\n * let val = customDedent(options)`the string to work on`\n * ```\n *\n * Supported custom functionality currently supports \"dropping\" the lowest\n * level of indentation as long as the lowest indentation count makes up\n * less than half the overall indentation values. It does this by setting the\n * lowest values to be equal to the second lowest values.\n *\n * @param {Object} options\n */\nexport function customDedent(\n  options: Object = {\n    dropLowest: undefined\n  }\n) {\n  return function (strings, ...subs) {\n    // handle the substitution stuff off the bat, just gets in the way\n    // if we try to handle it inline below\n    strings = handleSubstitutions(strings, subs).split('\\n');\n\n    // construct a small resuable function for trimming all initial whitespace\n    let trimL = s => s.replace(/^([ \\t]*)/, '');\n    let trimR = s => s.replace(/([ \\t]*)($)/, '$1');\n\n    // the first line is usually a misnomer, discount it if it is only whitespace\n    if (!trimL(strings[0]).length) {\n      strings.splice(0, 1);\n    }\n\n    // the same goes for the last line\n    if (!trimL(strings[strings.length - 1]).length) {\n      strings.splice(strings.length - 1, 1);\n    }\n\n    // count the indentation for each line; used below\n    let indents = strings.map(s => {\n      let search = /(^[ \\t]*)/.exec(s);\n      return search && search[1].length || 0;\n    });\n\n    // check to see if we should drop lowest (based on lowest being < half)\n    if (options.dropLowest) {\n      let isFn = obj => typeof obj === 'function';\n      let lowest = Math.min(...indents);\n      let occurences = indents.filter(o => o === lowest).length;\n      let nextLowest = Math.min(...[].concat(indents).filter(o => o !== lowest));\n      let test = isFn(options.dropLowest) && options.dropLowest || ((array, lowest, count) => count < array.length / 2);\n\n      if (test(indents, lowest, occurences)) {\n        indents = indents.map(o => o === lowest ? nextLowest : o);\n      }\n    }\n\n    // count the minimal amount of shared leading whitespace\n    let excess = Math.min(...indents) || 0;\n\n    // if the excessive whitespace is greater than 0, remove the specified\n    // amount from each line\n    strings = strings.map(s => s.replace(/([ \\t]*)$/, ''));\n    strings = strings.map(s => s.replace(new RegExp(`^[ \\t]{0,${excess}}`), ''));\n\n    // return a single joined string\n    return strings.join('\\n');\n  }\n}\n\n/**\n * This template tag function reduces any leading whitespace of each line of\n * the template string to the line with the least amount. If the first and/or\n * the last lines in the string are nothing but whitespace, then those lines\n * are omitted.\n *\n * @method dedent\n *\n * @param {Array<string>} strings the individual strings that appear around\n * the substitutions that follow in the parameter\n * @param {Array<mixed>} subs with the spread operator this becomes an array\n * of all the potential replacement values\n * @return {string} a combined and dedented string\n */\nexport function dedent(strings, ...subs) {\n  return customDedent()(strings, ...subs)\n}\n\nexport default dedent;\n"]}