{"version":3,"sources":["../src/functions.js"],"names":["handleSubstitutions","cautiouslyApplyEach","cautiouslyApply","measureIndents","customDedent","dedent","stripEmptyFirstAndLast","dropLowestIndents","NOOP_PREWORK","NOOP_PERLINE","NOOP_POSTWORK","DEDENT","DEDENT_DROP_LOWEST","DEDENT_FULL","variations","strings","subs","convert","object","string","join","Array","isArray","length","reduce","prev","cur","i","array","fns","log","keepOldValueOnFalseyReturn","items","forEach","item","itemIndex","itemArray","newItem","fn","bindFunctor","functor","bind","error","console","config","preWork","perLine","postWork","whitespace","regexp","RegExp","source","indents","split","map","s","a","search","exec","options","dropLowest","mask","has","get","ss","excess","Math","min","replace","gql","set","trimL","trimR","splice","values","lowest","delete","index"],"mappings":"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","file":"functions.js","sourceRoot":"src","sourcesContent":["// @flow\n\n// These constants can be discarded in the next major version where\n// customDedent is no longer present\nconst DEDENT = 1\nconst DEDENT_DROP_LOWEST = 2\nconst DEDENT_FULL = DEDENT | DEDENT_DROP_LOWEST\n\n// A short term solution to manage potential configurations for customDedent\n// in a low logic manner; i.e. without the need for excessive if statements\n// kill this in the next major revision\nconst variations: Map<Number, Function> = new Map()\n\n/**\n * One annoyance of working with tag functions is the conversion and inter-\n * weaving of the substitutions to get a string to modify in the first place.\n * This method does that and returns a string.\n *\n * Optionally you can specify a conversion function for each substitution\n * value. The signataure is `function (substitution): string`. It takes in a\n * substitution value, something in `${value}` within a template string and\n * receives a string as output. If none is supplied, a default function that\n * concatenates the value with an empty string is used. This will implicitly\n * invoke `.toString()` most of the time.\n *\n * @param {Array<string>} strings the strings that should be processed with\n * breaks wherever variable substitutions should occur. These map 1:1 to values\n * in `subs`\n * @param {Array<mixed>} subs the values that should be substituted into the\n * values found in\n * @param {Function} convert an optional function that can be used to coerce\n * the substitution to a form other than `sub.toString()`. It takes in the\n * substitution and should return a string value of some sort.\n */\nexport function handleSubstitutions(\n  strings: Array<string>,\n  subs: Array<mixed>,\n  convert: Function = (object) => '' + object\n): string {\n  let string = strings.join('');\n\n  if (subs && Array.isArray(subs) && subs.length) {\n    string = subs.reduce(\n      (prev, cur, i) => `${prev}${convert(cur)}${strings[i + 1]}`,\n      strings[0]\n    );\n  }\n\n  return string;\n}\n\n/**\n * Nearly identical to `cautiouslyApply`, this function works on an array of\n * items rather than a single item. The only other difference is that the\n * supplied functors receive the index of the item and the array the item is\n * contained within as second and third parameters, respectively.\n *\n * @param {Array<mixed>} array an array of values to apply each functor to\n * @param {Array<Function>} fns an array of `Function` objects that are to be\n * executed with the supplied `item` as its input and the new value as its\n * output. An error or fals\n * @param {boolean} log true if any errors caused by function execution should\n * be logged\n * @param {boolean} keepOldValueOnFalseyReturn if true and the functor returns\n * a falsey value, the value passed to it as a parameter is used instead\n * @return {Array<mixed>} a copy of the array passed as `array` but with\n * potentially modified internal values\n */\nexport function cautiouslyApplyEach(\n  array: Array<mixed>,\n  fns: Array<Function>,\n  log: boolean = true,\n  keepOldValueOnFalseyReturn: boolean = false\n): Array<mixed> {\n  let items = Array.from(array)\n\n  if (items && Array.isArray(items) && fns && Array.isArray(fns)) {\n    items.forEach((item, itemIndex, itemArray) => {\n      let newItem = item\n\n      fns.forEach(fn => {\n        try {\n          let bindFunctor = Array.isArray(fn) && fn[1]\n          let functor = bindFunctor\n            ? fn[0].bind(newItem)\n            : Array.isArray(fn) ? fn[0] : fn\n\n          if (keepOldValueOnFalseyReturn)\n            newItem = functor(newItem, itemIndex, itemArray) || newItem\n          else\n            newItem = functor(newItem, itemIndex, itemArray)\n        }\n        catch (error) {\n          if (log) {\n            console.error(error)\n          }\n        }\n      })\n\n      items[itemIndex] = newItem\n    })\n  }\n\n  return items\n}\n\n/**\n * Given an item that needs to be modified or replaced, the function takes\n * an array of functions to run in order, each receiving the last state of the\n * item. If an exception occurs during function execution the value passed is\n * the value that is kept.\n *\n * Optionally, when the function executes and returns the newly modified state\n * of the object in question, if that value is falsey it can be replaced with\n * the original value passed to the function instead. This is not true by\n * default\n *\n * `fns` is an array of functions, but any of the functions in the list are\n * actually a tuple matching [Function, boolean] **and** the boolean value is\n * true then the function within will be bound to the item it is operating on\n * as the `this` context for its execution before processing the value. It will\n * still receive the item as the first parameter as well.\n *\n * **NOTE: this will not work on big arrow functions**\n *\n * @param {mixed} item any JavaScript value\n * @param {Array<Function>} fns an array of `Function` objects that are to be\n * executed with the supplied `item` as its input and the new value as its\n * output. An error or fals\n * @param {boolean} log true if any errors caused by function execution should\n * be logged\n * @param {boolean} keepOldValueOnFalseyReturn if true and the functor returns\n * a falsey value, the value passed to it as a parameter is used instead\n * @return {mixed} the new value to replace the one supplied as `item`\n */\nexport function cautiouslyApply(\n  item: mixed,\n  fns: Array<Function|[Function, boolean]>,\n  log: boolean = true,\n  keepOldValueOnFalseyReturn: boolean = false\n): mixed {\n  if (fns && Array.isArray(fns)) {\n    fns.forEach(fn => {\n      try {\n        let bindFunctor = Array.isArray(fn) && fn[1]\n        let functor = bindFunctor\n          ? fn[0].bind(item)\n          : Array.isArray(fn) ? fn[0] : fn\n\n        if (keepOldValueOnFalseyReturn)\n          item = functor(item) || item\n        else\n          item = functor(item)\n      }\n      catch (error) {\n        if (log) {\n          console.error(error)\n        }\n      }\n    })\n  }\n\n  return item\n}\n\n/**\n * Measure indents is something that may be of use for any tag function. Its\n * purpose is to take a string, split it into separate lines and count the\n * leading whitespace of each line. Once finished, it returns an array of\n * two items; the list of strings and the matching list of indents which are\n * related to each other via index.\n *\n * The function also receives a config object which allows you to specify up\n * to three lists worth of functions.\n *\n * `preWork` is a list of functions that receive the following arguments in\n * each callback and are meant as a pluggable way to modify the initial string\n * programmatically by the consuming developer. Examples might be to prune\n * empty initial and final lines if they contain only whitespace\n *\n * ```\n * preWorkFn(string: string): string\n *\n *   - string: the supplied string to be modified by the function with the\n *     new version to be used as the returned value. If null or undefined is\n *     returned instead, the value supplied to the function will be used\n * ```\n *\n * `perLine` is list of functions that receive the following arguments in\n * each callback and are meant as a pluggable way to modify the line in\n * question. The expected return value is the newly modified string from which\n * to measure the indent of. Each item in the list will receive the modified\n * string returned by its predecessor. Effectively this is a map function\n *\n * ```\n * perLine(string: string, index: number, array: Array<string>): string\n * ```\n *\n * `postWork` is a list of functions that get called in order and receive\n * the final results in the form of an array containing two elements. The\n * first is the list of strings and the second is the list of measuredIndents.\n * The format of the supplied value (i.e. array of two arrays) is expected as\n * a return value. Failure to do so will likely end up as a bug someplace\n *\n * ```\n * postWork(\n *   array: Array<Array<string>, Array<number>>\n * ): Array<Array<string>, Array<number>>\n * ```\n *\n * All functions supplied to these arrays, if wrapped in an array with a\n * second parameter of true, will cause the function in question to be bound\n * with the item it is working on as the `this` context.\n *\n * @param {string} string see above\n * @param {Object} config see above\n * @param {RegExp} whitespace the defintion for whitespaced used within\n * @return {Array<Array<string>, Array<number>>} an array containing two\n * arrays; the first being an array of one line per index and the second being\n * an index matched array of numbered offsets indicating the amount of white\n * space that line is prefixed with\n */\nexport function measureIndents(\n  string: string|Array<string>,\n  config: Object = {\n    preWork: [],\n    perLine: [],\n    postWork: []\n  },\n  whitespace: RegExp = /[ \\t]/\n): Array<Array<string>, Array<number>> {\n  let regexp = new RegExp(`(^${whitespace.source}*)`)\n  let strings\n  let indents\n\n  if (Array.isArray(string)) {\n    string = string.join('\\n')\n  }\n\n  string = cautiouslyApply(string, config.preWork, true, true)\n  strings = string.split(/\\r?\\n/)\n  indents = strings.map((s, i, a) => {\n    let search\n\n    s = cautiouslyApply(s, config.perLine, true, false)\n\n    search = regexp.exec(s);\n    return search && search[1].length || 0;\n  });\n\n  return cautiouslyApply([strings, indents], config.postWork)\n}\n\n/**\n * The underpinning of `dedent()` is `customDedent()`. This function takes\n * an options object and returns a tag function. So direct usage would be\n * something like\n *\n * ```\n * let val = customDedent(options)`the string to work on`\n * ```\n *\n * Supported custom functionality currently supports \"dropping\" the lowest\n * level of indentation as long as the lowest indentation count makes up\n * less than half the overall indentation values. It does this by setting the\n * lowest values to be equal to the second lowest values.\n *\n * @param {Object} options\n *\n * @deprecated the options for customDedent seem to always be preferrable in\n * practice and as such, `dedent` and `gql` are simply aliases for the base\n * behavior in `customDedent` now. Expect `customDedent` to be removed in\n * future major revisions of `ne-tag-fns`\n */\nexport function customDedent(options: Object = { dropLowest: true }) {\n  let mask = DEDENT\n    | (options.dropLowest ? DEDENT_DROP_LOWEST : 0)\n\n  if (variations.has(mask)) {\n    return variations.get(mask)\n  }\n\n  return function (ss, ...subs) {\n    let [strings, indents] = measureIndents(\n      // handle the substitutions right off the bat, it will just make things\n      // easier all around\n      handleSubstitutions(ss, subs),\n\n      // pass in the handlers to strip empty head and tail strings and then\n      // drop the lowest value as this is often a requested feature\n      {\n        preWork: [stripEmptyFirstAndLast],\n        postWork: [\n          options.dropLowest\n            ? dropLowestIndents\n            : NOOP_POSTWORK\n        ]\n      }\n    )\n\n    // count the minimal amount of shared leading whitespace\n    let excess = Math.min(...indents) || 0;\n\n    // if the excessive whitespace is greater than 0, remove the specified\n    // amount from each line\n    if (excess > 0) {\n      strings = strings.map(s => s.replace(/([ \\t]*)$/, ''));\n      strings = strings.map(s => s.replace(\n        new RegExp(`^[ \\t]{0,${excess}}`), ''\n      ));\n    }\n\n    // return a single joined string\n    return strings.join('\\n');\n  }\n}\n\n/**\n * This template tag function reduces any leading whitespace of each line of\n * the template string to the line with the least amount. If the first and/or\n * the last lines in the string are nothing but whitespace, then those lines\n * are omitted.\n *\n * @method dedent\n *\n * @param {Array<string>} strings the individual strings that appear around\n * the substitutions that follow in the parameter\n * @param {Array<mixed>} subs with the spread operator this becomes an array\n * of all the potential replacement values\n * @return {string} a combined and dedented string\n */\nexport function dedent(strings, ...subs) {\n  return customDedent({dropLowest: true})(\n    strings,\n    ...subs\n  )\n}\n\n/**\n * An alternate name for `dedentDropLowest` that can be used to trigger syntax\n * highlighting when used with GraphQL SDL/IDL strings in some IDEs and editors\n *\n * @type {Function}\n * @see #dedentDropLowest\n * @see #customDedent\n */\nexport const gql = dedent\n\n// Create cached variation with false for all options\nvariations.set(DEDENT,\n  customDedent({dropLowest: false})\n)\n\n// Create cached variation with true for dropping lowest\nvariations.set(DEDENT | DEDENT_DROP_LOWEST,\n  customDedent({dropLowest: true})\n)\n\n/**\n * A `preWork` functor for use with `measureIndents` that strips the first and\n * last lines from a given string if that string has nothing but whitespace. A\n * commonly desired functionality when working with multiline template strings\n *\n * @param  {string} string the string to parse\n * @return {string} a modified string missing bits that make up the first and/\n * or last lines **if** either of these lines are comprised of only whitespace\n */\nexport function stripEmptyFirstAndLast(string: string): string {\n  let strings = string.split(/\\r?\\n/)\n  // construct a small resuable function for trimming all initial whitespace\n  let trimL = s => s.replace(/^([ \\t]*)/, '');\n  let trimR = s => s.replace(/([ \\t]*)($)/, '$1');\n\n  // the first line is usually a misnomer, discount it if it is only\n  // whitespace\n  if (!trimL(strings[0]).length) {\n    strings.splice(0, 1);\n  }\n\n  // the same goes for the last line\n  if (!trimL(strings[strings.length - 1]).length) {\n    strings.splice(strings.length - 1, 1);\n  }\n\n  return strings.join('\\n')\n}\n\n/**\n * A `postWork` functor for use with `measureIndents` that will modify the\n * indents array to be an array missing its lowest number.\n *\n * @param {[Array<string>, Array<number>]} values the tuple containing the\n * modified strings and indent values\n * @return {[Array<string>, Array<number>]} returns a tuple containing an\n * unmodified set of strings and a modified indents array missing the lowest\n * number in the list\n */\nexport function dropLowestIndents(\n  values: [Array<string>, Array<number>]\n): [Array<string>, Array<number>] {\n  let [strings, indents] = values\n  let set = new Set(indents)\n  let lowest = Math.min(...indents)\n\n  set.delete(lowest)\n\n  return [strings, Array.from(set)]\n}\n\n/**\n * A simple non operation preWork function that can make writing and reading\n * code that uses measureIndents easier to work with.\n *\n * @param {string} string any string value\n * @return {string} the value passsed in as `string`\n */\nexport function NOOP_PREWORK(string: string): string {\n  return string\n}\n\n/**\n * A simple non operation preWork function that can make writing and reading\n * code that uses measureIndents easier to work with.\n *\n * @param {string} string any string value\n * @param {number} index the index of `string` within `array`\n * @param {Array<string>} array the array containing `string`\n * @return {string} the value passsed in as `string`\n */\nexport function NOOP_PERLINE(\n  string: string,\n  index: number,\n  array: Array<string>\n): string {\n  return item\n}\n\n/**\n * A simple non operation postWork function that can make writing and reading\n * code that uses measureIndents easier to work with.\n *\n * @param {[Array<string>, Array<number>]} values the tuple containing the\n * modified strings and indent values\n * @return {[Array<string>, Array<number>]} the same value passed in as `values`\n */\nexport function NOOP_POSTWORK(\n  values: [Array<string>, Array<number>]\n): [Array<string>, Array<number>] {\n  return values\n}\n\n// Export the variations in the case someone needs to tweak the runtime\nexport { variations }\n\nexport default dedent;\n"]}