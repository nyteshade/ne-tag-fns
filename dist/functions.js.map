{"version":3,"sources":["../src/functions.js"],"names":["handleSubstitutions","customDedent","dedent","strings","subs","convert","object","string","join","Array","isArray","length","reduce","prev","cur","i","options","dropLowest","undefined","split","indents","map","s","search","exec","isFn","obj","lowest","Math","min","occurences","filter","o","nextLowest","concat","test","array","count","trimL","replace","trimR","splice","excess","RegExp"],"mappings":";;;;;QAuBgBA,mB,GAAAA,mB;QAiCAC,Y,GAAAA,Y;QAiFAC,M,GAAAA,M;;;AAvIhB;;;;;;;;;;;;;;;;;;;;;AAqBO,SAASF,mBAAT,CACLG,OADK,EAELC,IAFK,EAGLC,UAAqBC,MAAD,IAAY,KAAKA,MAHhC,EAIG;AACR,MAAIC,SAASJ,QAAQK,IAAR,CAAa,EAAb,CAAb;;AAEA,MAAIJ,QAAQK,MAAMC,OAAN,CAAcN,IAAd,CAAR,IAA+BA,KAAKO,MAAxC,EAAgD;AAC9CJ,aAASH,KAAKQ,MAAL,CACP,CAACC,IAAD,EAAOC,GAAP,EAAYC,CAAZ,KAAmB,GAAEF,IAAK,GAAER,QAAQS,GAAR,CAAa,GAAEX,QAAQY,IAAI,CAAZ,CAAe,EADnD,EAEPZ,QAAQ,CAAR,CAFO,CAAT;AAID;;AAED,SAAOI,MAAP;AACD;;AAED;;;;;;;;;;;;;;;;AAgBO,SAASN,YAAT,CACLe,UAAkB;AAChBC,cAAYC;AADI,CADb,EAIL;AACA,SAAO,SAAShB,MAAT,CAAgBC,OAAhB,EAAyB,GAAGC,IAA5B,EAAkC;AACvC;AACA;AACAD,cAAUH,oBAAoBG,OAApB,EAA6BC,IAA7B,EAAmCe,KAAnC,CAAyC,IAAzC,CAAV;;AAEA;AACA;AACA,QAAIhB,QAAQQ,MAAR,KAAmB,CAAvB,EAA0B;AACxBR,gBAAUA,QAAQ,CAAR,EAAWgB,KAAX,CAAiB,IAAjB,CAAV;AACD;;AAED;AACA,QAAIC,UAAUjB,QAAQkB,GAAR,CAAYC,KAAK;AAC7B,UAAIC,SAAS,YAAYC,IAAZ,CAAiBF,CAAjB,CAAb;AACA,aAAOC,UAAUA,OAAO,CAAP,EAAUZ,MAApB,IAA8B,CAArC;AACD,KAHa,CAAd;;AAKA;AACA,QAAIK,QAAQC,UAAZ,EAAwB;AACtB,UAAIQ,OAAOC,OAAO,OAAOA,GAAP,KAAe,UAAjC;AACA,UAAIC,SAASC,KAAKC,GAAL,CAAS,GAAGT,OAAZ,CAAb;AACA,UAAIU,aAAaV,QAAQW,MAAR,CAAeC,KAAKA,MAAML,MAA1B,EAAkChB,MAAnD;AACA,UAAIsB,aAAaL,KAAKC,GAAL,CAAS,GAAG,GAAGK,MAAH,CAAUd,OAAV,EAAmBW,MAAnB,CAA0BC,KAAKA,MAAML,MAArC,CAAZ,CAAjB;AACA,UAAIQ,OACDV,KAAKT,QAAQC,UAAb,KAA4BD,QAAQC,UAArC,KACI,CAACmB,KAAD,EAAQT,MAAR,EAAgBU,KAAhB,KAA2BA,QAAQD,MAAMzB,MAAN,GAAe,CADtD,CADF;;AAKA,UAAIwB,KAAKf,OAAL,EAAcO,MAAd,EAAsBG,UAAtB,CAAJ,EAAuC;AACrCV,kBAAUA,QAAQC,GAAR,CAAYW,KAAKA,MAAML,MAAN,GAAeM,UAAf,GAA4BD,CAA7C,CAAV;AACD;AACF;;AAED;AACA,QAAIM,QAAQhB,KAAKA,EAAEiB,OAAF,CAAU,aAAV,EAAyB,EAAzB,CAAjB;AACA,QAAIC,QAAQlB,KAAKA,EAAEiB,OAAF,CAAU,eAAV,EAA2B,IAA3B,CAAjB;;AAEA;AACA,QAAI,CAACD,MAAMnC,QAAQ,CAAR,CAAN,EAAkBQ,MAAvB,EAA+B;AAC7BR,cAAQsC,MAAR,CAAe,CAAf,EAAkB,CAAlB;AACArB,cAAQqB,MAAR,CAAe,CAAf,EAAkB,CAAlB;AACD;;AAED;AACA,QAAI,CAACH,MAAMnC,QAAQA,QAAQQ,MAAR,GAAiB,CAAzB,CAAN,EAAmCA,MAAxC,EAAgD;AAC9CR,cAAQsC,MAAR,CAAetC,QAAQQ,MAAR,GAAiB,CAAhC,EAAmC,CAAnC;AACAS,cAAQqB,MAAR,CAAerB,QAAQT,MAAR,GAAiB,CAAhC,EAAmC,CAAnC;AACD;;AAED;AACA,QAAI+B,SAASd,KAAKC,GAAL,CAAS,GAAGT,OAAZ,KAAwB,CAArC;;AAEA;AACA;AACAjB,cAAUA,QAAQkB,GAAR,CAAYC,KAAKA,EAAEiB,OAAF,CAAU,WAAV,EAAuB,EAAvB,CAAjB,CAAV;AACApC,cAAUA,QAAQkB,GAAR,CAAYC,KAAKA,EAAEiB,OAAF,CAAU,IAAII,MAAJ,CAAY,YAAWD,MAAO,GAA9B,CAAV,EAA6C,EAA7C,CAAjB,CAAV;;AAEA;AACA,WAAOvC,QAAQK,IAAR,CAAa,IAAb,CAAP;AACD,GA3DD;AA4DD;;AAED;;;;;;;;;;;;;;AAcO,SAASN,MAAT,CAAgBC,OAAhB,EAAyB,GAAGC,IAA5B,EAAkC;AACvC,SAAOH,eAAeE,OAAf,EAAwB,GAAGC,IAA3B,CAAP;AACD;;kBAEcF,M","file":"functions.js","sourceRoot":"src","sourcesContent":["// @flow\n\n/**\n * One annoyance of working with tag functions is the conversion and inter-\n * weaving of the substitutions to get a string to modify in the first place.\n * This method does that and returns a string.\n *\n * Optionally you can specify a conversion function for each substitution\n * value. The signataure is `function (substitution): string`. It takes in a\n * substitution value, something in `${value}` within a template string and\n * receives a string as output. If none is supplied, a default function that\n * concatenates the value with an empty string is used. This will implicitly\n * invoke `.toString()` most of the time.\n *\n * @param {Array<string>} strings the strings that should be processed with\n * breaks wherever variable substitutions should occur. These map 1:1 to values\n * in `subs`\n * @param {Array<mixed>} subs the values that should be substituted into the\n * values found in\n * @param {Function} convert an optional function that can be used to coerce\n * the substitution to a form other than `sub.toString()`. It takes in the\n * substitution and should return a string value of some sort.\n */\nexport function handleSubstitutions(\n  strings: Array<string>,\n  subs: Array<mixed>,\n  convert: Function = (object) => '' + object\n): string {\n  let string = strings.join('');\n\n  if (subs && Array.isArray(subs) && subs.length) {\n    string = subs.reduce(\n      (prev, cur, i) => `${prev}${convert(cur)}${strings[i + 1]}`,\n      strings[0]\n    );\n  }\n\n  return string;\n}\n\n/**\n * The underpinning of `dedent()` is `customDedent()`. This function takes\n * an options object and returns a tag function. So direct usage would be\n * something like\n *\n * ```\n * let val = customDedent(options)`the string to work on`\n * ```\n *\n * Supported custom functionality currently supports \"dropping\" the lowest\n * level of indentation as long as the lowest indentation count makes up\n * less than half the overall indentation values. It does this by setting the\n * lowest values to be equal to the second lowest values.\n *\n * @param {Object} options\n */\nexport function customDedent(\n  options: Object = {\n    dropLowest: undefined\n  }\n) {\n  return function dedent(strings, ...subs) {\n    // handle the substitution stuff off the bat, just gets in the way\n    // if we try to handle it inline below\n    strings = handleSubstitutions(strings, subs).split('\\n')\n\n    // if the template string is a single value, split it into an array\n    // broken out by line\n    if (strings.length === 1) {\n      strings = strings[0].split('\\n')\n    }\n\n    // count the indentation for each line; used below\n    let indents = strings.map(s => {\n      let search = /(^[ \\t]*)/.exec(s)\n      return search && search[1].length || 0\n    })\n\n    // check to see if we should drop lowest (based on lowest being < half)\n    if (options.dropLowest) {\n      let isFn = obj => typeof obj === 'function'\n      let lowest = Math.min(...indents)\n      let occurences = indents.filter(o => o === lowest).length\n      let nextLowest = Math.min(...[].concat(indents).filter(o => o !== lowest))\n      let test = (\n        (isFn(options.dropLowest) && options.dropLowest)\n        || ((array, lowest, count) => (count < array.length / 2))\n      )\n\n      if (test(indents, lowest, occurences)) {\n        indents = indents.map(o => o === lowest ? nextLowest : o)\n      }\n    }\n\n    // construct a small resuable function for trimming all initial whitespace\n    let trimL = s => s.replace(/^([ \\t]*)/mg, '')\n    let trimR = s => s.replace(/([ \\t]*)($)/mg, '$1')\n\n    // the first line is usually a misnomer, discount it if it is only whitespace\n    if (!trimL(strings[0]).length) {\n      strings.splice(0, 1)\n      indents.splice(0, 1)\n    }\n\n    // the same goes for the last line\n    if (!trimL(strings[strings.length - 1]).length) {\n      strings.splice(strings.length - 1, 1)\n      indents.splice(indents.length - 1, 1)\n    }\n\n    // count the minimal amount of shared leading whitespace\n    let excess = Math.min(...indents) || 0\n\n    // if the excessive whitespace is greater than 0, remove the specified\n    // amount from each line\n    strings = strings.map(s => s.replace(/([ \\t]*)$/, ''))\n    strings = strings.map(s => s.replace(new RegExp(`^[ \\t]{0,${excess}}`), ''))\n\n    // return a single joined string\n    return strings.join('\\n')\n  }\n}\n\n/**\n * This template tag function reduces any leading whitespace of each line of\n * the template string to the line with the least amount. If the first and/or\n * the last lines in the string are nothing but whitespace, then those lines\n * are omitted.\n *\n * @method dedent\n *\n * @param {Array<string>} strings the individual strings that appear around\n * the substitutions that follow in the parameter\n * @param {Array<mixed>} subs with the spread operator this becomes an array\n * of all the potential replacement values\n * @return {string} a combined and dedented string\n */\nexport function dedent(strings, ...subs) {\n  return customDedent()(strings, ...subs)\n}\n\nexport default dedent;\n"]}